# ■ 9주차 (5월 2일)

- 모바일용 VR 기기 개인 보급

## AR (증강현실)

- 현실에 기반에 가상의 데이터를 더해 만드는 가상의 현실
- AR의 3요소
    - 결합
    - 3D
    - 인터렉션
- GPS를 통한 사용자의 위치 추적
- 가속도와 자이로스코프 센서를 활용한 사용자의 시야 추적
- VR은 가상 세계 안으로 진입하기 때문에 몰입도가 높음
- AR은 현실을 가상세계화 시킨 것이라 현실성이 높음


# ■ 10주차 (5월 9일)

- 이번에 핵심적으로 다룰 내용은 **애니메이션**, **씬 전환**
- 스마트폰을 좌우로 기울이면 기울기에 따라 화면도 위로 옮겨지게 개발

- Rigidbody 2D 컴포넌트로 간단하게 물리 법칙을 구현할 수 있음. 중력이 적용됨
    - Rigidbody에서 중력과 물리 연산의 영향을 무시하기 위해선 Body Type을 Kinematic으로 전환해주어야 함. 이럴 경우 중력과 외부의 힘에 영향을 받지 않게 됨
    - Z축으로 넘어지는 것을 방지하기 위해 Z축을 Freeze Rotate
- Collider 컴포넌트를 통해 충돌 판정을 트리거할 범위를 바로 지정할 수 있음.
    - Collider의 종류엔 원, 캡슐, 사각형, 자유형 등이 존재
    - 필요에 따라 콜라이더를 여러 개 사용하여 원하는 형태의 피격 범위를 지정해줄 수 있음

- 오브젝트를 찾는 Find 메서드엔 여러가지 변형이 존재함
    - Find(오브젝트이름) : 씬 중에서 오브젝트 이름과 일치하는 게임 오브젝트 찾아서 리턴
    - FindWithTag(태그이름) : 씬 중에서 태그 이름과 일치하는 게임 오브젝트 한 개 찾아서 리턴
    - FindGameObjectsWithTag(태그이름) : 태그 이름과 일치하는 게임 오브젝트 여러개 배열로 리턴
    - FindObjectOfType(타입이름) : 씬 중에서 타입 이름과 일치하는게임 오브젝트 한 개 리턴
    - FindObjectsOfType(타입이름) : 씬 중에서 타입 이름과 일치하는게임 오브젝트 여러개 리턴
    
- AddForce 메서드로 힘을 가하는 방식으로 이동하면 Physics가 알아서 움직임을 계산해줌
- transform.localScale = new Vector3(Key, 1, 1); 코드로 움직임에 따라 스프라이트 반전이 가능

## 애니메이션

- 유니티는 연속된 여러개의 이미지를 재생시켜 애니메이션으로 만들 수 있음
- 일러스트를 한 컷씩 교체하거나 애니메이션 작성과 전환을 일관되게 할 수 있는 **메카님** 구조를 사용
    - 메카님덕분에 게임을 설계할 때 스프라이트 애니메이션을 작성해 각 애니메이션의 교체 시기를 지정할 수 있고, 메카님이 오브젝트 상태를 판단하고 자동으로 애니메이션을 바꿔줌
- **스프라이트, 애니메이션 클립, 애니메이터 컨트롤러, Animator 컴포넌트**의 관계 이해

- 스프라이트 : 한 장 한 장의 일러스트
- 애니메이션 클립 : 스프라이트를 연속 넘겼을 때 애니메이션으로 보이도록 정리한 파일
    - 재생할 스프라이트 정보, 재생 속도, 재생 시간 등이 설정되어있음
- 애니메이터  컨트롤러 : 애니메이션 클립을 정리하여 어느 시점에 어느 애니메이션 클립을 재생할지 지정
- Animator 컴포넌트 : 해당 컴포넌트에 애니메이터를 넣어두면 재생할 수 있게 됨

- 애니메이션 클립을 만든 뒤 Add Property로 해당 클립에서 연속 재생할 사항을 정한다.
- Sprite Renderer → Sprite의 +를 눌러 스프라이트를 재생하도록 한다.
- 원하는 스프라이트를 원하는 프레임에 삽입하여 애니메이션이 재생되게끔 만들고, 마지막 스프라이트는 1프레임밖에 안 나오므로 뒤쪽에 Add Keyframe으로 간격을 하나 둬준다.
- 스크립트를 작성하여 플레이어의 이동속도가 재생 속도에 비례하도록 만들어줄 수 있음
    - this.animator.speed = speedx / 2.0f;

### 점프 구현 및 애니메이터

- Jump 애니메이션 클립을 만든 후, 해당 애니메이션 클립의 Loop Time 체크를 해제
- Walk중 점프 버튼이 눌리면 Jump 애니메이션 재생
- Jump중 Jump 애니메이션 재생이 끝나면 Walk 애니메이션 재생
- 이를 위해선 애니메이터를 설정해주어야 함

- 애니메이터엔 다음과 같은 노드가 있음
    - Entry : 애니메이션 시작할 때 Entry 노드로 전환
    - Any State : 현재 상태와 관계없이 언제나 특정 애니메이션으로 전환 가능
    - Exit : 애니메이션을 종료하고자 할 때 Exit 노드로 전환
- 원하는 노드에서 원하는 노드로 이동할 땐 Make Transition을 눌러 화살표를 설정
    - Has Exit Time : 애니메이션 재생이 종료되면 자동으로 다른 애니메이션으로 전환할지 여부
    - Exit Time : 애니메이션의 종료 시간을 정규화 시간(0.0 ~ 1.0)으로 설정
    - Transition Duration : 다음 애니메이션으로 전환하는 시간을 정규화 시간(0.0 ~ 1.0)으로 설정
    - Transition Offset : 다음 애니메이션을 재생하는 시간을 정규화 시간(0.0 ~ 1.0)으로 설정
- Has Exit Time을 활성화함으로서 점프 애니메이션 재생이 끝나면 Walk로 돌아감

- Walk에서 Jump로 전환하는 시점은 점프 버튼이 눌리는 순간 (트리거)이 발동되면 전환으로
- Animator 창 왼쪽에 Parameters 탭을 눌러 Trigger 파라미터를 추가
    - Float : 전환 조건에 부동소수를 사용하는가
    - Int : 전환 조건에 정수를 사용하는가
    - Bool : 전환 조건에 불 값을 사용하는가
    - Trigger : 전환 조건이 트리거인가
- Has Exit Time을 비활성화하고, 컨디션에서 JumpTrigger가 발동시로 설정
- 이후 플레이어 스크립트에서 점프 시 해당 코드를 작동
    - this.animator.SetTrigger("JumpTrigger");
- 해당 메서드로 애니메이터 컴포넌트의 파라미터를 작동해줄 수 있음
- Y축 방향 이동 속도를 보고 점프중이라면 애니메이션 속도를 1.0으로 고정하도록 설정

## 플레이어 이동에 따른 카메라 이동

- 카메라도 게임 오브젝트이다.
- 일반 오브젝트와 마찬가지로 컨트롤러 스크립트로 움직인다.
- 플레이어가 수직 이동할 때마다 카메라가 따라다니도록 프레임마다 플레이어 좌표 조사, 카메라 Y좌표에 반영해주는 방식으로 카메라를 이동시킨다.

## 깃발 충돌

- 깃발에 닿으면 클리어 씬으로 전환되도록 플레이어와 깃발의 충돌 판정 구현
- collider 컴포넌트를 사용해 OnCollisionEnter2D 메서드를 호출하는 방식으로 구현
- Collision 모드 (충돌모드) 와 Trigger 모드 (통과모드) 가 존재
    - OnCollisionEnter2D : 충돌한 순간 호출
    - OnCollisionStay2D : 충돌 중 호출
    - OnCollisionExit2D : 충돌이 끝난 순간 호출
- 충돌 판정을 하기 위해선 오브젝트 중 적어도  한 쪽에는 Rigidbody 컴포넌트가 있어야 함

## 게임 씬 전환

- 유니티에서는 게임 화면을 묶어 씬이라고 부른다.
- 보통 게임 시작의 TitleScene이 존재하고, MenuScene이나 GameScene등이 존재
- 이번 게임에선 클리어했을 때 ClearScene을 로드해볼 것
- 씬을 로드하거나, 재시작 등을 하기 위해선 아래의 패키지를 임포트해야 한다.
    - using UnityEngine.SceneManagement;
- 이후 LoadScene() 메서드를 사용하여 원하는 씬을 로드할 수 있다.
- 이제 게임에서 사용할 모든 씬들은 File → Build Settings에 등록해주어야 함
- 가장 먼저 실행될 씬은 0번 씬

# ■ 11주차 (5월 16일)

- 파티클 이펙트를 적용
- Terrian 사용
- 3D 게임 제작

# ■ 12주차 (5월 23일)

## 3D 게임 개발

- 3D 리소스들을 가지고 게임 개발
- Light를 사용해 광원을 만들 수 있음
    - Directional Light는 직선의 빛
    - Point Light는 구 형태로 뻗어나가는 빛
    - Spotlight는 조명처럼 원뿔 형태로 나가는 빛
    - Area Light는 일정 구간에 뿌리는 빛
- Light의 위치를 조절하여 그림자의 위치도 조정할 수 있음
- Intensity를 조정하여 빛의 세기를 결정할 수 있음
- Project Settings - Quality - Shadow Distance를 더 작게 조정하여 그림자의 픽셀 크기를 조절

- 충돌 감지 메서드는 하나뿐인데, 충돌할 수 있는 아이템의 종류는 여러가지임
- 따라서 오브젝트마다 Tag를 매겨 충돌하는 아이템의 종류를 파악할 수 있음
- Project Settings - Tags and Layers에서 태그와 레이어들을 추가할 수 있음

- 난수를 발생해 랜덤값을 줄 수 있음
- 그러나 컴퓨터의 난수는 이미 모든 순서가 정해져있는 의사 난수
- 수열의 패턴만 알면 다음 난수를 알 수 있게 됨
- 따라서, 난수의 시드를 바꾸어 의사 난수 등장 패턴 자체를 바꾸는 방식으로 변조 가능

- 레벨디자인의 최대 목표는 플레이어를 설레게 하는 것
- 난이도와 즐거움의 곡선 그래프를 잘 그어 가장 높은 지점을 캐치할 것
- 제한시간이 너무 길면 지루해질 수 있으므로,  적당한 선에서 끊기
- 이것이 레벨 디자인

# ■ 13주차 (5월 30일)

- VR로 동작하는 3D 로봇 헌터 게임 제작
- 에셋스토어, 미리 준비해둔 스크립트를 적용하기만 해도 완성
- Steam VR 카메라, 컨트롤러 무기 모델링
- Player Damage Effect
- UI 제작
- 적 로봇 리스폰