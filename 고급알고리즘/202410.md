# 6주차

## 자료구조

- 데이터를 어떻게 저장하고 관리할지 결정하는 구조
- 배열, 리스트, 스택, 큐, 데크, 트리, 그래프

## ADT

- 추상적 데이터 타입 (Abstract Data Type)
- 자료 구조를 논리적으로 정의한 개념으로, 데이터의 구조와 그 위에서 수행할 수 있는 연산들을 추상화한 것.
- 어떤 데이터를, 어떻게 저장할지만 정의하고, 어떤 기술이나 연산을 쓸지 자세하게 기술하지 않는다.
- 데이터와 연산의 추상화 : 데이터의 저장 방식, 메모리 관리 등 구체적인 부분은 구현 내용 없고, 데이터의 논리적 구조와 연산에만 초점을 맞춘다.
    - 즉, ADT에선 리스트가 어떻게 구현되는진 정보는 없고, 리스트에서 수행할 수 있는 연산(삽입, 삭제, 접근)만 정의한다.
- 인터페이스 중심 설계 : 사용자가 데이터 내부 구현 방식을 몰라도 ADT에서 정의된 연산들을 사용해 원하는 작업을 수행할 수 있다.
    - 즉, 무엇을 할 수 있는지에 대해 정의하며, 어떻게 그것을 할 것인지는 ADT의 구현에 맡긴다.
- 구현과 인터페이스 분리 : ADT는 구현과 인터페이스를 분리한 개념이다. 사용자는 ADT의 연산과 기능만 알면 되며, 그 내부가 배열인지, 연결 리스트로 구현되었는지 등은 알 필요가 없다.
- 리스트, 트리, 그래프, 스택, 큐는 ADT이다.
- 배열과 연결리스트, 해시 테이블은 ADT가 아니다.
    - ADT가 아닌 것들을 어떻게든 논리적으로 잘 조합하여, 기능을 하게 되는 자료구조를 만들어 ADT가 되는 것이다.
- ADT는 데이터 구조와 연산으로 구성된다.
    - 데이터 구조의 논리적 표현을 정의한다. 예를 들어 리스트는 데이터가 순차적으로 나열된 구조, 스택은 LIFO 구조이다.
    - 연산은 데이터를 조작하는 방법이다. 예를 들어 스택 ADT는 push, pop, peek같은 연산이 정의될 수 있다.

## 배열

- 각 원소는 동일한 데이터 타입을 가져야 한다.
- 임의의 원소에 상수 시간 O(1)으로 접근 가능
    - A[i] = A0 + (i * element size)
- 단, 특정 값을 탐색하는 데에는 선형 시간 O(n)이 소요된다.
    - 이는 정렬되지 않은 경우에, 첫 번째부터 마지막 원소까지 순차 비교 필요
- 그러나 배열이 정렬된 경우, 이진 탐색을 사용하면 O(log n)이 소요된다.
- 삽입/삭제에는 선형 시간 O(n)이 소요된다.
    - 연속적인 구조로 인해 삽입 또는 삭제 후, 나머지 요소를 전부 시프트해야 하기 때문이다.
    - 단, 끝에 삽입하는 경우엔 상수 시간 O(1)이 걸리며, 만약 배열의 크기를 초과하는 데이터가 삽입되면 리사이징이 필요해 O(n)이 소요된다.
- 배열은 연속적으로 할당받기 때문에, 서로 인접하게 배치된다.
- 고정 크기 : 일반적인 배열은 고정된 크기를 가지며, 배열 선언 시 그 크기를 지정해야 한다. 그 크기를 초과하면, 동적 배열로 크기를 변경해야 한다. 만약 배열의 크기를 조정하게 되면, 더 큰 배열로 데이터를 복사하므로 O(n)이 소요된다.
- 메모리 낭비 : 배열은 고정된 크기이기 때문에, 사용되지 않는 공간이 남을 경우 메모리 낭비가 발생한다.
- 빠른 임의 접근 : 주소 계산을 통해 상수 시간으로 임의 원소에 접근 가능
- 메모리 연속성 : 연속된 메모리 블록에 데이터를 저장하기에, CPU 캐시의 효율정을 높일 수 있다. 인접한 메모리 블록에 저장되어, 캐시 적중률이 높아진다.
- 배열과 동적배열의 차이 : 배열은 고정 크기, 동적 배열은 배열의 크기가 가변적이다. 동적 배열은 더 유연하지만, 크기 확장 시 리사이징이 일어나 O(n)이 소요된다. 일반적으로 2배의 크기로 할당되며, 배열이 복사된다.
- 동적 배열의 동작 과정
    - 초기화 : 초기엔 고정 배열처럼 초기 크기를 설정후 초기화
    - 데이터 삽입 : 삽입 중 새로운 더 큰 배열을 할당하고 새 배열로 복사
        - 이는 끝에 삽입하는 경우 시간이 O(1)이 걸리고, 도중 리사이징이 일어나도 O(1)이 압도적으로 많기 때문에 평균 시간 복잡도를 O(1)로 본다. 단 중간 삽입의 경우 그냥 선형이다.
    - 크기 확장 : 꽉 찰 때마다 2배 크기로 확장하는데, 이는 지수적 확장으로 빈번한 확장 작업을 줄여 성능 저하를 최소화한다.
- 메모리 관리 : 필요한 만큼 메모리를 차지하는데, 크기 확장 과정에서 잠깐 동안 기존 배열과 새로운 배열 두 개의 메모리를 차지한다.
- 주로 사용되는 환경
    - 임의 접근이 자주 필요할 때
    - 정렬된 데이터를 처리할 때
    - 고정된 크기의 데이터를 저장할 때

## 리스트

- 연결 리스트는 데이터를 순서대로 저장하는 선형 자료 구조로, 동적 크기와 빠른 삽입 및 삭제가 가능하다. 각 요소는 인덱스를 가지며 순차적으로 접근할 수 있다.
- 연결 리스트는 배열과 달리 고정된 크기 없이, 데이터의 삽입과 삭제에 따라 동적으로 크기가 변화한다.
- 배열 기반 리스트 (ADT)
    - 데이터를 연속된 메모리 공간에 저장하며, 인덱스를 사용해 상수 시간 접근 O(1)이 가능하다.
    - 동적으로 크기를 확장할 수 있다.
    - 끝 삽입은 O(1)이 걸리며, 중간 삽입 삭제는 O(n)이 소요된다.
- 연결 리스트 (Not ADT)
    - 노드들이 포인터를 사용해 서로 연결한 형태의 리스트이다.
    - 각각의 노드는 데이터와 다음 노드를 가리키는 참조를 포함한다.
    - 배열과 달리 물리적으로 연속되지 않은 메모리 공간에 데이터를 저장할 수 있다. 삽입과 삭제가 빠르지만, 상수 시간 임의 접근이 불가능하다 .
    - 접근 시간은 O(n)이 소요되고, 삽입/삭제는 O(1)이 소요된다.
        - 삽입/삭제 O(1)은, 특정 노드를 알고 있을 경우 그 위치에서 삽입과 삭제가 빠른 것이다. 한마디로, 삽입 삭제를 하려면 노드의 위치를 알아야 한다.
- 단일 연결 리스트
    - 각 노드가 다음 노드에 대한 포인터를 가지는 리스트이다.
    - 한 방향으로만 탐색이 가능하다.
    - 데이터와 함께 1개의 포인터를 저장한다.
- 이중 연결 리스트
    - 각 노드가 앞 노드와 뒤 노드에 대한 포인터를 가지는 구조이다.
    - 양방향 탐색이 가능하고, 더 효율적인 노드 관리가 가능하다.
- 환형 연결 리스트
    - 마지막 노드가 첫 번째 노드로 연결되는 형태의 리스트로, 원형 구조이다.
    - 양방향 탐색을 지원하는 원형 이중 연결 리스트도 존재한다.
- 연결 리스트 활용
    - 메모리 할당 관리 : 동적 메모리 할당 시스템에서 프리 리스트를 사용해 메모리 블록을 관리할 때 연결 리스트가 효과적으로 사용된다.
    - 스택, 큐, 그래프 구현 : 스택과 큐 자료구조를 구현할 때 쓰이며, 그래프는 인접 리스트를 통해 그래프의 간선을 저장하여 사용한다.
- 배열 기반 리스트 활용
    - 파이썬 리스트와 같은 고급 언어에서 제공된다.

## 스택

- LIFO 구조의 자료 구조
- push와 pop이 있고, peek 또는 top, isEmpty 등의 연산이 있다.
- 한쪽 끝에서만 데이터의 삽입과 삭제가 가능한 단방향 접근이다.
- 연속된 메모리 공간에 데이터를 저장하기에 연결 리스트로 구현된다.
- 배열 기반 스택은 메모리 상에 연속적으로 데이터를 저장하는 방식으로, 배열 끝에서 삽입과 삭제가 이루어지며, 배열이 꽉 차면 데이터 복사가 필요하다.
- 연결 리스트 기반 스택은 노드들을 연결하는 방식으로 구현된다.
- 삽입, 삭제, 탐색, 공백확인 모두 상수 시간 O(1)이 소요된다.
- 함수 호출 스택 (콜스택)
    - 컴퓨터 시스템에서 함수가 호출될 때마다, 호출 정보가 스택에 저장된다. 이는 재귀 호출에서 특히 중요하다.
- 괄호 유효성 검사에 쓰인다.
- DFS 알고리즘, 백트래킹, 문자열 뒤집기에서 사용된다.

## 큐

- 가장 먼저 삽입된 요소가 가장 먼저 삭제된다.
- 이는 여러 시스템에서 공정하게 (선착순) 작업을 처리한다.
- 주요 연산
    - enqueue : 큐의 뒤쪽에 데이터를 추가
    - dequeue : 큐의 앞쪽에 데이터를 제거하고 반환
    - front : 큐 앞 데이터를 제거하지 않고 반환
    - is Empty
- 배열 기반 큐 : 배열을 사용해 큐를 구현할 수 있는데, 이는 배열이 가득 차면 공간 부족이 일어나므로 주로 사용하지 않는다.
- 원형 큐 : 공간 낭비를 해결하기 위해 원형 배열을 사용하여 큐를 구현할 수 있다.
- 연결 리스트 기반 큐 : 동적 연결 리스트를 사용해 큐를 구현할 수 있다. 크기 제한이 없어지며, 삽입 삭제에 O(1)이 소요된다.
- 작업 스케쥴링 : 운영체제에서 작업 스케줄링에 사용된다.
- 프린터 작업 대기열 : 프린터는 작업 대기열에 들어온 순서대로 처리한다.
- 네트워킹과 데이터 스트리밍 : 큐는 데이터 패킷을 전송하기 위해 버퍼 역할을 한다. 스트리밍 역시  데이터를 순차적으로 처리한다.
- 너비 우선 탐색에 사용된다.
- 캐시 시스템에서 오래된 데이터 삭제, 새 데이터 추가 방식으로 큐를 사용해 LRU 방식을 구현할 수 있다.

## 해시 테이블

- 키와 값으로 구성되어, 키를 통해 값에 접근하는 방식으로 저장
- 각 데이터는 고유한 키를 가진다.
- 해시 함수는 키를 입력받아 이를 해시테이블의 인덱스로 변환하는 역할을 한다. 해시 함수는 데이터를 고정 크기의 해시 값으로 변환하여, 특정 위치에 매핑한다.
- 해시 함수는 해시테이블의 성능에 결정적 역할을 하기에, 충돌을 최소화하는 것이 중요하다. 즉, 균등한 분포를 제공하는 해시 함수가 선호된다.
- 서로 다른 두 개 이상의 키가 같은 해시 값을 갖는 해시 충돌을 개방 주소법, 체이닝 등으로 해결할 수 있다.
- 평균적으로 삽입, 삭제, 탐색에 O(1)의 시간 복잡도가 소요된다.

# 7주차

## 그래프

- 정점과 간선으로 구성된 비선형 자료구조이며, 순환될 수 있다.
- 네트워크, 지도, SNS에서 사용된다.
- 간선에 방향이 없는 무향 그래프, 간선에 방향이 있는 유향 그래프가 존재한다.
- 그래프의 종류
    - 무향 그래프
    - 유향 그래프
    - 가중치 그래프 : 간선에  가중치가 부여된 그래프로, 비용, 거리, 시간을 나타냄
    - 완전 그래프 : 모든 정점(노드)이 서로 연결된 그래프
    - 희소 그래프 : 간선의 수가 정점의 수에 비해 적은 그래프
    - 밀집 그래프 : 간선의 수가 정점의 수에 비해 많은 그래프
- 그래프의 표현 방법
    - 인접 행렬 (2차원 배열), 그래프의 간선 존재 여부를 O(1) 시간에 확인 가능
    
    | 0 | 1 | 1 |
    | --- | --- | --- |
    | 1 | 0 | 0 |
    | 1 | 0 | 0 |
    - 인접 리스트 : 각 정점에 이웃 정점의 리스트 저장
    
    | A | B, C |
    | --- | --- |
    | B | A |
    | C | A |
- BFS, DFS, Shortest Path 알고리즘에서 사용된다.
- 그래프 관련 정리
    - 하나의 간선은 두 노드에 연결되므로, 한 그래프의 총 차수의 개수는 간선의 개수 * 2이다.
    - 홀수의 차수를 가지는 노드의 개수는 짝수이다.
    - 모든 노드의 in-degree의 합과 out-degree의 합은 서로 같으며, 간선의 수와 같다.
- 부분 그래프 : 한 그래프에서 노드와 간선의 일부만으로 만든 그래프
- 생성부분 그래프 : 한 그래프에서 모든 노드와 일부 간선만으로 만든 그래프
- 연결요소 : 한 그래프에서 서로 연결되어있는 이웃 집합의 개수
- 오일러 경로 : 그래프에서 모든 연결선을 한번씩만 통과하는 걸로 꼭짓점 여러번 통과 가능  (=한붓 그리기)
- 오일러 순회 : 그래프에서 꼭짓점은 여러번 통과하지만, 각 연결선을 한번씩만 통과하는 순회 (=한붓 그리기 후 시작과 끝이 같음)
- 오일러 경로가 되기 위한 필요충분조건은 그래프가 연결그래프이며, 홀수 차수인 꼭짓점이 0개 또는 2개이다.
- 오일러 순회가 되기 위한 필요충분조건은 그래프가 연결그래프이며, 모든 꼭짓점의 차수가 짝수이다.
- 해밀턴 경로 : 그래프에서 모든 꼭짓점을 한번씩만 통과하지만 시작점으로 돌아오지 않는 경로
- 해밀턴 순회 : 해밀턴 경로 후 출발점으로 돌아오는 순회
- 동형 (Isomorphism) : 겉보기엔  달라보이지만 노드와 간선의 구조가 완전히 같은 그래프
- 평면 그래프 : 어떤 연결선도 서로 교차하지 않는 그래프. 간선을 옮겨서 겹치지 않게 만든다면 평면그래프이다.
    - 오일러 공식 r = e - v + 2를 만족하면 평면그래프이다.
    - r(영역의 수, 가둬진 영역과 바깥영역 포함), e(연결선의 수), v(노드의 수)
- 그래프의 탐색
    - DFS (깊이 우선 탐색)
        - 인접한 정점 중 방문하지 않은 노드를 방문하고, 모두 방문하면 이전 정점으로 돌아가며 시작부터 깊이 들어가는 탐색
        - 재귀 알고리즘, 스택을 사용함
    - BFS (너비 우선 탐색)
        - 인접한 정점들을 차례로 방문하며, 각 정점들의 인접 정점들을 또 하나씩 방문해감
        - 큐를 사용함

## 트리

- 사이클이 존재하지 않는 그래프
- 루트(Root)라 불리는 특별한 노드가 한 개 존재하며, 루트로부터 다른 모든 노드로 가는 경로가 항상 유일하게 존재한다