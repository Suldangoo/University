# 2주차

- 컴퓨터 : 명령어를 순서에 따라 디지털로 처리하는 기계
- 아날로그 → 디지털
    - 샘플링(X축), 퀀타이제이션(양자화, Y축), 코딩
- 컴퓨터가 하나의 명령어로 실행될 수 있는 데이터를 워드라고 한다.
- nbit 컴퓨터는 레지스터의 크기 word로 한 번에 표현할 수 있는 최댓값

## 보수

- 컴퓨터가 음수 계산을 덧셈으로 하기 위해 보수를 사용
- 2의 보수를 쓰면 1의 보수보다 한 개 더 많은 수의 표현을 할 수 있다.
    - 1의 보수, 부호와 절댓값은 +0과 -0을 표현하는 방식이 각각 다르다.
    - 저장 효율이 좋을 뿐만 아니라 전력효율이 2의 보수가 더 좋다.
- 2진법에서 3초과부호를 사용하면, 0~9까지 최소 한 비트에 1이 들어가기 때문에 단선 등에 의한 신호두절을 구별할 수 있으며, 5 이상일 때부터 최상우 비트가 1이 되므로 반올림에 유용하다.
- 1의 보수는 모든 2진수 값을 뒤집기
- 2의 보수는 모든 2진수 값을 뒤집고 +1
    - 2의 보수가 부호만 다른 두 값 (7, -7)을 더할 때 0000 0000이 된다.

## 실수 표현

- 부호 / 지수부 / 가수부
- (부호) x (가수) x (밑수)^(지수)
- 정규화
    - 2진수의 경우 정규화를 하면 가수부는 밑수인 2보다 항상 작은 수인 1로 시작하여, 생략 가능
    - 1100.011(2)를 정규화하면, 맨 앞이 1이 나올때까지 소수점을 최대한 땡기기
    - 즉 1.100011 * 2^3 으로 정규화 가능
- 그렇다면 정수부 / 실수부였던 1100.011을
    - 지수부 / 가수부인 ____.1000011으로 바꿀 수 있다.
    - 여기서 지수부엔 정규화 값인 2^3에서 3을 삽입해서 11.1000011이 되…
    - 는줄 알았더니, 11은 IEEE 754표준에서 편향된 지수를 도입해 10000010으로 변환된다.
- 편향 지수값은
    - 01111111 = 0
    - 10000000 = 1…
- IEEE 754에서 하프 프레시전 타입으론 부호 1비트, 지수 5비트, 가수 10비트로 16비트를 쓴다.
- 3비트 초과코드의 지수부, 4비트의 가수부에서 8비트 스트링 부동소수점 표기방식
    - 01101011 → 0/110/1011 → 부호 / 지수 / 가수
    - 양수 / 2 / → 1.1011 * 2^2 = 110.11
    - 6.3

# 3주차

## 인코딩 방식

- BCD : 이진화 십진법, 4비트 ~ 6비트
- ASCII : 7비트 인코딩 방식, 128개의 문자 표현 가능. 알파벳, 숫자, 기호, 제어 문자 포함
    - 각 문자는 해당하는 7비트 이진수로 표현된다.
    - 확장 ASCII는 상위 128개의 추가문자 포함.
    - A는 65, a는 97
- EBCDIC : IBM 개발의 확장된 BCD
- Unicode : 모든 언어의 문자 표현 가능한 범용 문자 인코딩 표준
    - UTF-8, UTF-16 등의 인코딩 방식으로 1바이트 ~ 4바이트
    - 백만 개 이상의 문자 인코딩

## Big-O

- 알고리즘 표현 방법
    - 자연언어 표현 (플로우 차트)
        - 순서도에서는 등호(=)를 쓰지 않고, 화살표 (←)를 사용
    - 의사코드 (슈도 코드)
    - 프로그래밍 언어
- 시간 복잡도 : 수행 시간 분석
- 공간 복잡도 : 수행 시 필요로 하는 메모리 공간 분석
- 일반적으로 상수와 계수를 제거하고 복잡도를 단순화해 나타낸다
- Big-O는 점근적 상한 (worst) 표기법으로, 최악의 경우를 나타낸다
- 우선순위
    - O(1) : 상수형 (Constant) : 리스트에서 첫 번째 원소 출력
    - O(log n) : 로그형 (Logarithmic) : 이진탐색
    - O(n) : 선형 (Linear) : 리스트의 모든 원소 출력, 비례
    - O(n log n) : 로그선형 : 퀵정렬, 병합정렬, 분할정복 알고리즘
    - O(n^2) : 2차형 : 리스트의 모든 원소들에 대해 모든 원소를 각각 곱해 출력 (2중 반복문)
    - O(2^n) : 지수형
    - O(n!) : 팩토리얼
- 공간복잡도
    - 코드를 저장하는 고정 공간
    - 알고리즘이 필요로 하는 변수를 저장하는 가변 공간
- 시간 복잡도와 공간 복잡도는 반비례하는 경향이 있다

# 4주차

## 선택 정렬

- 무식하게 생각했을 때 가장 먼저 떠오르는, 원시적이고 기초적인 알고리즘.
- **가장 작은 것을 선택**해서 제일 앞으로 보내는 알고리즘
- 순서는 미는 것이 아닌, **교환**하는것
- 알고리즘
    - 남아있는 배열들 중 min값을 찾는다.
    - min을 전부 탐색했다면, 가장 앞 원소와 swap한다.
- 불안정 정렬 : 동일한 값의 원소들이 처음의 순서를 유지하지 못할 수 있다.
- 시간 복잡도 : 최악, 최선, 평균 모두 O(n^2)
    - 상수 계수도 높다.

## 버블 정렬

- 선택 정렬과 같이 몹시 직관적인 해결 방법
- 바로 옆에 붙어있는 값과 비교하여, 더 작은 값을 앞으로 보내는 알고리즘
- 구현은 가장 쉽지만 가장 비효율적인 알고리즘
- 데이터 swap만 하며 별도의 변수나 메모리가 필요 없으므로 공간복잡도가 O(1)이다.
- 이미 정렬된 배열에 실시간으로 새로운 데이터가 들어오는 경우에 적합
- 알고리즘
    - 인접한 두 자료를 비교하여, 정렬되어있지 않다면 swap한다.
    - 1순회가 끝나면 마지막 원소를 제외하고 반복한다.
    - 개선된 알고리즘 : 교환이 일어나지  않으면 조기 종료한다.
- 안정 정렬 : 동일한 값의 원소들이 정렬 후에도 순서가 유지된다.
- 시간 복잡도 : 최악, 평균이 O(n^2), 최선의 경우 O(n)
    - 개선되지 않았다면 상수 계수가 높다.

## 삽입 정렬

- 각 숫자를 적절한 위치에 삽입하는 방법으로,  필요할 때만 위치를 바꾼다.
- 정렬이 되어있다고 가정한다는 점에서, 특정 경우에 매우 빠르다.
    - 즉 버블과 유사하게 거의 정렬되어있고, 실시간 들어오는 상황에서 매우 좋다.
- 알고리즘
    - 맨 앞 원소부터 이미 정렬된 테이블이라고 가정한다.
    - 두 번째 원소를 잡고, 앞에 정렬된 테이블을 순차적으로 검색한다.
    - 정렬할 원소보다 큰 값이 나오면 검색을 중단하고, 해당 자리에 삽입한다.
    - 모든 데이터에 대해 검색 중 삽입을 하고, 삽입이 끝나면 반복문을 빠져나오는 것을 반복한다.
- 시간 복잡도 : 최악, 평균이 O(n^2), 최선의 경우 O(n)
    - 버블과 같아보이지만, 상수 계수가 낮다.
- 안정 정렬 : 동일한 값의 원소들이 정렬 후에도 순서가 유지된다.

## 퀵 정렬

- 대표적인 분할 정복 알고리즘으로, 평균 속도가 매우 빠르다.
- 피봇(Pivot)이라고 불리는 제어값을 정해, 피봇을 중심으로 전체 데이터를 피봇보다 작은 값과 큰 값으로 나누어 정렬한다.
- 알고리즘
    - 리스트에서 기준이 되는 하나의 피벗 요소를 선택한다.
    - 피벗을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 나눈다.
    - 나눈 두 개의 리스트에 대해 피봇을 정하고 분할하는 과정을 재귀적으로 반복한다.
    - 각 분할이 완료되면 병합 과정이 없어도 리스트가 완성된다.
- 시간 복잡도 : 평균과 최선이 O(n log n), **최악의 경우 O(n^2)**
    - 상수 계수가 낮다.
    - 모든 알고리즘의 시간복잡도는 최악의 경우를 생각하는데, 퀵 정렬은 O(n log n)으로 표기한다. 이는 피벗 선택 기준이 극단적으로 잘못되었을 때 이론적인 수치이며, 실제로 알고리즘을 사용하며 피벗 기준이 틀려 최악의 경우가 나오는 확률이 거의 없기 때문이다.
- 불안정 정렬 : 동일한 값의 원소들이 처음의 순서를 유지하지 못할 수 있다.
- 피벗 선택 방법
    - 첫 번째 원소, 마지막 원소, 랜덤 피벗, 중간값 피벗

## 합병 정렬 (병합 정렬)

- 대표적인 분할 정복 알고리즘으로, 퀵 정렬과 동일하게 O(n log n)의 시간복잡도이다.
- 병합 정렬은 정확히 반절씩 나눈다는 점에서 최악의 경우에도 O(n log n)을 보장한다.
- 알고리즘
    - 리스트의 길이가 1이 될 때까지 리스트를 절반으로 나눈다.
    - 길이가 1이 되면 이를 정렬된 상태로 간주하고, 두 리스트들끼리 묶어 정렬된 상태로 병합한다.
    - 즉 리스트 길이가 1이 될 때까진 분할의 반복, 다시 하나의 리스트가 될 때까지 합병의 반복
- 시간 복잡도 : 최선, 최악, 평균이 모두 O(n log n)
- 안정 정렬 : 동일한 값의 원소들이 정렬 후에도 순서가 유지된다.