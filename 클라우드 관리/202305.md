# ■ 9주차 (5월 3일)

- 192.168.0.0/22 3개로 분할한 서브넷에 인스턴스와 EIP 할당 복습
- AWS 러너 랩 리셋 시 즐겨찾기 등의 메뉴는 유지, 만든 모든 리소스들이 제거됨

## 라우팅 테이블

- 기본적으로 VPC와 서브넷을 만들면 기본 라우팅 테이블이 만들어지며, 우리는 편집만 하면 됨
- 서브넷 별로 다르게 라우팅 테이블을 할당할 수 있으며, 어떤 서브넷은 인터넷에 연결하고 어떤 서브넷은 인터넷 연결을 안 할 수 있음
- 즉, 원하는 서브넷에만 인터넷 게이트 웨이를 연결하는 것이 가능

- IGW로 인터넷 연결이 **안** 되어있는 서브넷 : **Private Subnet**
- IGW로 인터넷 연결이 되어있는 서브넷 : **Public Subnet**
- 명시적 서브넷 연결 : 서브넷과 라우팅 테이블 직접 연결
- 묵시적 서브넷 연결 : 명시적 연결이 없는 경우 기본 라우팅 테이블에 연결 (기본 : 예)
    - 모든 서브넷은 기본적으로 묵시적 연결이 되어있고, 이런 경우엔 명시적 연결이 없는 서브넷 목록에 추가되어있는 모습을 확인할 수 있음.
- 기본 서브넷이라도 서브넷 - 작업 - 라우팅 테이블 연결 편집 들어가서 원하는 라우팅 테이블 할당해주면 그 서브넷은 명시적으로 연결된 것임
- 그러면 원하는 서브넷들은 IGW에 연결된 라우팅 테이블에 할당해주고, 원하는 서브넷들은 인터넷이 연결되어있지 않은 라우팅 테이블에 할당해줄 수 있음
    - 인터넷에 연결이 되어있지 않더라도 같은 VPC 내에 있는 서브넷들은 기본적으로 서로 통신 가능

- 왜 프라이빗 서브넷이 필요한가?
    - 인터넷에 연결된 장치는 항상 공격의 대상이 됨
    - 인터넷망에 직접 연결되지 않아도 되는 서버는 가급적 네트워크와 격리된 곳에 위치시키는 것이 보안 원칙
    - 연결하지 않아도 되는 서버는 전부 다 프라이빗에 몰아넣고, 인터넷 연결이 필요한 것만 퍼블릭
    - DB 서버는 백엔드 서버에선 접근이 가능하지만 인터넷으로 접근은 불가능하도록 하면 보안성 향상

- Bastion Host
    - 인터넷 게이트 웨이랑 연결되어있는 성벽 인스턴스가 퍼블릭 서브넷에 위치하고, 이 인스턴스가 프리베이트 서브넷에 있는 진짜 인스턴스로 전달해주는 2중 연결 구조로 보안성을 강화함
    - 이렇게 할 경우엔 진짜 인스턴스와 성벽 인스턴스가 서로 가용영역이 일치해야 함
    - 이럴 경우 진짜 인스턴스와 성벽 인스턴스가 같은 퍼블릭 키를 가지고 있음
    - 우리가 다운받은 ppk 프라이빗 키로 성벽 인스턴스의 퍼블릭 키와 인증하여 연결
    - 이후 성벽 인스턴스의 프라이빗 키와 진짜 인스턴스의 퍼블릭 키로 인증하여 연결

- Bastion Host로 프라이빗 서브넷 서버에 접속하는 과정
    1. 성벽 인스턴스 내에 프라이빗 키 파일을 러너랩 환경에서 복사해서 넣어두기
    
    ```bash
    scp -i ~/.ssh/labsuser.pem ~/.ssh/labsuser.pem ec2-user@성벽 인스턴스의 퍼블릭 IP:/home/ec2-user/
    ```
    
    1. 성벽 인스턴스로 접속
    
    ```bash
    ssh -i ~/.ssh/labsuser.pem ec2-user@성벽 인스턴스의 퍼블릭 IP
    ```
    
    1. 성벽 인스턴스 내에서 진짜 인스턴스로 접속
    
    ```bash
    ssh -i labsuser.pem ec2-user@진짜 인스턴스의 프라이빗 IP
    ```
    
    - 즉, 러너랩에 있던 프라이빗 키 → 성벽 인스턴스에 복사 후 이중 인증으로 연결
    - 성벽 인스턴스와 진짜 인스턴스는 같은 가용영역의 같은 VPC 내에 있으므로 프라이빗 ip로 서로 통신하게 되므로 마지막 연결은 프라이빗 ip로 해주어야 함
- 그러나 이 방법은 bastion host에 대한 SSH key를 강탈당할 경우 bastion host에 있는 키 모두 강탈당할 수 있는 위험성이 존재
- 이 절차를 손쉽게 하며 보안성이 뛰어나게 처리하는 **SSH agent forwarding** 이라는 방법이 존재

- 왜 같은 가용영역으로 설정했는가?
    - AWS에서 가용영역은 데이터 센터를 의미
    - 가용영역 간의 통신은 데이터 전송량에 따라 비용이 발생
    - 같은 가용영역이면 서브넷이 달라도 비용이 발생하지 않음
    - 즉, 베스쳔 호스트와 프라이빗 서버가 같은 가용영역에 있어야 서로 통신할 때 통신비가 발생하지 않음
    - 따라서 비용효율적으로 고가용성을 확보하는 구조를 잘 생각해서 아키텍처를 설계해야 함
        - 같은 가용영역끼리 퍼블릭과 프라이빗 서브넷을 하나씩 만들어두는 방식
        - 고가용성도 확보하고, 비용효율도 확보하는 구조

# ■ 10주차 (5월 10일)

- 퍼블릭, 프라이빗 서브넷 두 개씩 만들어 각각 인스턴스 하나씩 두고 접속하는 복습

## 인터넷과 NAT

- 공인 IP : 네트워크에서 장치를 특정하는 방법은 IP인데, IP의 개수는 한정적이고 인터넷은 거대한 하나의 IP 범위를 갖는 네트워크이다. 이를 극복하기 위한 NAT 시스템으로 대표성을 갖는 IP 하나를 가지고 인터넷과 통신할 수 있게 됨. 이 것이 공인IP
- 인터넷의 IP는 국제기구 (ICANN) 에서 관리, 총괄함.
- KISA(한국인터넷진흥원) 에서 한국의 IP 관리를 위임받아 처리
- 인터넷에 연결하기 위해서 장치들은 인터넷으로 연결되는 경로와 인터넷에서 사용할 공인 IP가 필요

- 가정에서 공유기를 통한 인터넷 연결 - NAT
    - ISP(SK, KT같은 인터넷 사업자) 에서 공유기에 공인 IP를 할당해줌
    - 공유기와 연결된 기기는 공인 IP를 받지 않았지만 NAT를 이용해 인터넷을 사용할 수 있음
        - 공유기 하나가 공인 IP를 가지고 있고 (59.232.22.32)
        - 해당 공유기가 사설 IP 범위를 지니며 (192.168.0.0/25)
        - 공유기에 연결된 기기들은 사설 IP가 부여된다 (192.168.0.4)
    - 즉, 내부 IP가지고는 인터넷의 대상들과는 통신되지 않음.
    - 따라서 공유기에 연결된 기기들은 공유기로부터 대표 IP (공인 IP) 를 빌려 인터넷을 통신함
    - 이것이 NAT의 기본
- NAT(Network Address Translation) : 공유기에서 내부에 연결된 장치들이 인터넷으로 접근할 때 공유기에 할당된 공인 IP를 이용하도록 지원
- Port(포트) : 하나의 컴퓨터에 대해서 네트워크를 사용하는 어플리케이션이 여러 개일 경우 이들을 구분하기 위한 ID 역할을 수행
    - 포트는 하나의 컴퓨터 내에서 유일하게 어플리케이션을 구분 (0~65535까지 사용 가능)
    - 한 컴퓨터는 공인IP가 하나뿐인데, 한 컴퓨터가 여러 개의 어플리케이션을 사용한다면 각 어플리케이션이 요청받은 결과를 주소만을 보는것이 아닌 포트를 포함해서 주소를 보고 결과값을 줌

- 장치 → 공유기 → 인터넷 → 공유기 → 장치 로 데이터가 순환됨
- 장치 → 공유기 → 인터넷으로 갈 땐 공인 IP를 가지고 NAT로 수행
- 인터넷 → 공유기도 해당 공인 IP로 데이터를 보내줌
- 공유기 → 장치로 데이터를 보낼 땐 NAT Table에 기록된 프라이빗IP와 포트를 보고 전달
- NAT 테이블엔 아래와 같은 내용들이 기록됨
    - 출발 장치 : 192.168.0.2:1000
    - 공유기에서 받은 포트 : 59.293.22.32:2000
    - 목적지 : 50.29.32.44:3000
- 따라서 역순으로 오더라도 동일한 IP 하나만으로 목적지를 정확히 지정해줄 수 있게 됨
- 이렇게 포트를 이용해 장치가 연결되는 것을 포워딩 (forwarding)이라고 하게 됨

- 단, 외부에서 요청을 줄 땐 노트북, 스마트폰, 컴퓨터 등의 장치에 바로 직접 접근은 불가능
- 외부는 오로지 공유기밖에 모름. 공인 IP는 공유기에만 할당되어 있으므로 특정할 수 있는 장치는 공유기뿐임
- 즉, NAT는 내부에서 외부로 나가는건 가능하지만 외부에서 내부로 오는건 불가능 (일방통행)
- 외부에서 내부로 올 땐 공유기가 포트를 사용하여 특정 대상을 집어줘야 함

## EC2 인스턴스에서의 NAT 인터넷 사용

- 실습에서 했던 프라이빗 서브넷에 가둬진 인스턴스가 이걸 사용하여 인터넷과 통신이 가능하다!
- 프라이빗 인스턴스가 NAT로부터 공인 IP를 발급받아 인터넷으로 나가는 것이 가능
- 그러나 반대로, 인터넷에서 해당 프라이빗 인스턴스로 들어올 순 없음
- 즉, 일방통행으로 나가기만 할 수 있는 것
- 이것은 NAT 게이트웨이 리소스로 실현 가능함

- NAT 게이트웨이를 생성할 수 있음
- 그러나 이것은 인터넷 게이트웨이처럼 VPC에 할당하는 것이 아닌, 서브넷에 할당하는 것
- 어떤 서브넷에 NAT 게이트웨이를 생성할지 지정해주어야함. 그런 어떤 서브넷에?
- 반드시 **Public 서브넷**에 만들어주어야 함!
    - 프라이빗 인스턴스가 쓸 것이지만, NAT 게이트웨이 자체는 인터넷과 통신 가능해야 함
- 연결 유형은 퍼블릭으로 지정
    - 인터넷으로 연결한다는 것. 프라이빗으로 할 경우 다른 프라이빗 네트워크와 연결한다는 의미
- 탄력적 IP를 할당받아야 함. 여기서 EIP를 직접 생성해서 하지 않아도 버튼 하나로 바로 EIP를 할당받을 수 있음

- 이제 이 NAT 게이트웨이를 프라이빗 서브넷에 규칙으로 추가해주어야 함
- 프라이빗 서브넷으로 가서 라우팅 편집 → 0.0.0.0/0 을 NAT 게이트웨이 대상으로 규칙 추가
- 이러면 퍼블릭 → 인터넷 게이트웨이, 프라이빗 → NAT 게이트웨이 연결이 성립됨
- 이제 프라이빗 인스턴스에 접속해서 ping으로 인터넷에 연결확인이 가능함

## 보안 그룹 : 네트워크에 대한 접근 제어

- 인터넷에 노출된 이상 브루트포스 해킹으로 무작위 비밀번호 대입에 대한 공격이 이루어질 수 있음
- 또한 요청을 마구잡이로 넣어 트래픽이 초과되는 D-DOS 공격도 이루어질 수 있음
- 이런 사항들을 대비해서 보안을 쳐두는 것이 보안 그룹에서 이루어짐

- 보안 그룹 (Security Gruop)을 통해 EC2 인스턴스에 접근 가능한 네트워크 영역을 제한
    - 아웃바운드 / 인바운드 규칙을 통해 들어오고 나가는 트래픽을 제어
        - 트래픽 : 네트워크를 통해 교환되는 패킷의 흐름
        - 패킷 : 네트워크를 통해 장치 간에 교환되는 데이터
- EC2 인스턴스에서 아웃바운드 규칙에 따라 네트워크로 연결된 장치로 이동
    - 아웃바운드 규칙이 다른 장치로 나가는 패킷을 제어
- 외부 장치가 인바운드 규칙에 따라 EC2 인스턴스로 이동
    - 인바운드 규칙이 다른 장치에서 EC2 인스턴스로 들어오는 패킷을 제어
- 즉, 안에서 밖으로 나가거나 밖에서 안으로 들어올 때 바로 나가는 것이 아닌 보안 그룹에서 한번 아웃바운드나 인바운드 규칙에서 체크를 하고 위배된다면 비허용, 괜찮다면 허용해주는 것

- 아웃바운드와 인바운드에 아무런 규칙이 없다면 어떤 트래픽도 허용되지 않음
- 아웃바운드 규칙에서 EC2 인스턴스에서 접근하는 외부의 네트워크 대역 설정
- 인바운드 규칙에서 EC2 인스턴스로 접근할 수 있는 외부의 네트워크 대역 설정
    - 예를 들어 0.0.0.0/0 을 허용하면 외부로 나가는 모든 트래픽 허용
    - 그러나 192.168.0.0/24 만을 허용하면 해당 대역으로만 트래픽 허용
    - 하나의 IP하고만 통신하고 싶다면 196.10.0.8/32

- 중요한 점으로, 아웃바운드가 허용된 곳으로 보낸 요청에 대한 응답은 인바운드 규칙과 상관 없이 반드시 허용
    - 인바운드 규칙이 지정한 대역이 아닌 곳이어도, 우리의 아웃바운드 규칙에 따라 우리가 먼저 요청을 보내고 그에 대한 응답이 온 것이라면 허용시켜준다.
- 단, 외부에서 시작된 요청은 인바운드 규칙에 의해 통제됨
- 어디서 먼저 시작했느냐가 매우 중요

- 우리는 AWS 아카데미 실습 환경용 서버 → EC2 인스턴스로 원격 접속을 할 것임
- NAT 게이트 웨이가 가지고 있는 Public IP 를 확인하는 명령어
    - curl [https://check](https://check)ip.amazonaws.com
- 위 명령어로 우리 AWS 아카데미 실습 환경용 서버의 NAT 게이트웨이 공인 IP를 볼 수 있음
- 우리는 EC2 인스턴스의 보안 그룹 규칙을 수정하여 나의 러너랩 터미널에서만 접근할 수 있도록 접근제어를 할 것임

1. 러너 랩의 NAT 게이트 웨이가 가지고있는 퍼블릭 IP를 알아둔다
2. Bastion Host용 인스턴스에 등록되어있는 보안 그룹을 찾는다
3. 해당 보안 그룹의 이름을 bastion으로 수정한다
4. 해당 보안 그룹의 인바운드 규칙을 편집한다
5. SSH 서버 (포트번호 22) 에서 0.0.0.0/0 이 아닌 알아둔 러너랩 퍼블릭 IP/32 로 지정한다
6. 이러면 인바운드 규칙은 대역 하나로 고정, 아웃바운드 규칙은 0.0.0.0/0 으로 오픈되어있다

- 이러면 Bastion Host로 들어가는 것은 러너랩 환경으로 고정되어있다
- 이제 진짜 EC2 인스턴스로 들어가는 인바운드 규칙을 로컬 영역에서만 접근할 수 있도록 (동일한 VPC 내에서만) 인바운드 규칙을 설정해줄 것이다
- 물론 둘 다 아웃바운드 규칙은 0.0.0.0/0:ALL 로 전부 오픈이다

1. 이번엔 보안 그룹을 직접 생성해서 할당해주는 것도 해볼 것이다
2. 보안 그룹을 생성한다
3. 보안 그룹의 이름을 짓고, 설명도 작성한다
4. VPC는 우리가 만든 인스턴스가 있는 VPC로 지정해준다
5. 인바운드 규칙을 추가한다
6. 사용자 지정 TCP 유형에서 우선은 포트 범위를 22로만 두어 SSH만 허용하도록 작성
7. 접근 가능한 IP CIDR를 내 VPC 범위와 똑같이 작성
8. 태그도 직접 추가
9. 보안그룹을 생성했다면 인스턴스 화면으로 가 기존의 private 인스턴스를 선택
10. 작업 - 보안 - 보안 그룹 변경을 눌러 기존의 보안 그룹을 제거하고 방금 만든 보안 그룹을 추가

- 이렇게 되면 해당 private 서버엔 같은 VPC에서만 접근하도록 설정이 됨
- 보안 그룹 당 기본 인바운드 60, 아웃바운드 60, 총 120개의 규칙을 지정 가능 (증량 가능)
- 네트워크 인터페이스 당 기본 5개, 최대 16개의 보안 그룹 지정 가능
    - 보안 그룹을 여러 개 사용 가능하다는 의미이다

# ■ 11주차 (5월 17일)

- 기존의 퍼블릭 / 프라이빗 VPC 구현을 일일히 해도 되지만, VPC를 생성할 때 VPC 등 으로 체크하여 여러가지 리소스들을 일괄적으로 생성할 수 있다.
- 단, 보안그룹은 직접 생성해주어야 한다.
    - 보안그룹은 2개를 생성해서, 인바운드 규칙을 각각 다르게 만든다.
    - 한 인바운드 규칙은 우리 강의실 컴퓨터 IP에서 HTTP로 접근 가능하게 생성
    - 한 인바운드 규칙은 AWS Learner Lab 환경의 NAT Gateway IP에서 SSH로 접근 가능하게
    - 단, 두 개 모두 다음 실습 때 적용되지 않음
        - 강의실 자리 바꾸면 컴퓨터 IP가 달라짐
        - AWS Learner Lab도 NAT Gateway가 여러개라 IP가 달라질 수 있음
- 참고로, 인바운드만 만들어져있고 아웃바운드가 만들어져 있지 않은 경우
    - 당연히 해당 서버에서 외부로 요청은 불가능
    - 단, 외부에서 해당 서버로 요청을 보냈을 때 응답은 가능
    

## Network ACL (NACL)

- 보안그룹은 방화벽 역할을 하는 리소스
- 그 외에도 방화벽 역할을 하는 리소스가 하나 더 있음 → NACL

- 보안그룹은 EC2 인스턴스 차원에 존재하는 문지기
    - 인스턴스에서의 아웃바운드, 인바운드 규칙을 정하는 것이 보안 그룹
- NACL은 서브넷 차원에 존재하는 문지기
    - 서브넷에서의 아웃바운드, 인바운드 규칙을 정하는 것이 NACL

- 즉, 한 서브넷에 여러 개의 인스턴스가 있다는 가정
    - 동일 서브넷의 EC2 인스턴스들끼리 통신할 때, 보안그룹의 영향을 받음
    - 그러나, NACL의 영향은 받지 않음

- EC2 → 외부 네트워크 장치
    - 보안그룹의 아웃바운드 규칙을 체크
    - NACL의 아웃바운드 규칙을 체크
    - 접근 완료
- 외부 네트워크 장치 → EC2
    - NACL의 인바운드 규칙을 체크
    - 보안그룹의 인바운드 규칙을 체크
    - 접근 완료

- 보안 그룹의 경우엔 아무런 규칙이 없으면 기본적으로 통신이 되지 않음
    - 보안 그룹은 반드시 허용하는 IP 대역만을 설정하며, 우선순위랄게 없음
- NACL은 트래픽에 대한 허용과 거부로 구성되어있음
- NACL 생성 시 기본적으로 인/아웃 모두 0.0.0.0/0 에 대한 거부가 설정되어있고 제거 불가
    - 즉, 일단 이 친구도 기본적으론 다 막혀있음
- NACL에 허용과 거부가 동시에 있을 경우 **낮은 규칙번호가 우선순위가 높음**
    - 0.0.0.0/0의 모든 거부는 규칙번호가 무한(*)임. 즉, 우선순위가 반드시 가장 낮음
- 0.0.0.0/0 을 Allow(허용) 하면 서브넷 외부로 나가는 모든 트래픽 허용
- 0.0.0.0/0 을 Deny(거부) 하면 서브넷 외부로 나가는 모든 트래픽 거부
- 둘 다 동시에 있을 경우, 규칙 번호가 낮은 것이 더 우선됨

- NACL의 세팅사항
    - 규칙 번호
    - 프로토콜
    - 포트 범위
    - 소스 (IP CIDR 범위)
    - 허용 / 거부

- 보안그룹의 경우엔 인바운드 규칙이 없더라도, 내가 보낸 요청(아웃바운드)에 대한 응답은 모두 허용
    - 해당 트래픽이 요청인지 응답인지 상태를 늘 체크하기 때문에 가능
    - Stateful F.W
- 그러나 NACL은 요청인지, 응답인지에 대한 정보를 몰라서 내가 보낸 요청에 대한 응답이어도 인바운드 규칙의 범위 내에 없다면 거부하게 됨
    - 상태를 체크하지 않음. 즉 인바운드 규칙도 다 만들어주어야 함
    - Stateless F.W
    
- 두 서브넷간의 통신을 하려면, 한 서브넷과 인스턴스의 보안그룹, NACL과 다른 서브넷과 인스턴스의 보안그룹, NACL을 모두 설정해줘야 성공적으로 통신이 가능함
- 단 하나 예외로, 자기 자신에 대한 규칙은 없어도 괜찮음. 즉, 동일 서브넷 안에서의 여러 EC2 인스턴스들의 통신은 NACL을 따지지 않음

- NACL은 모든 응답을 고려해야하므로 웬만하면 규칙번호 100에 올 트래픽
- 보안 그룹은 외부에서 오는 응답은 인바운드를 고려하지 않아도 됨
- 단, 보안 그룹 선에서 외부에서 오는 요청을 체크해야 함
    - 유형 : SSH
    - 프로토콜 : TCP
    - 포트범위 : 22
    - 소스 : 외부 요청 장치의 IP CIDR 범위

## EC2 인스턴스 서브넷에서의 NACL 할당

- 기본적으로 VPC를 생성할 때 할당되어있는 NACL의 기본 규칙
    - 100 올 트래픽 0.0.0.0/0 허용
    - *     올 트래픽 0.0.0.0/0 거부
- NACL을 새로 만들었을 때 기본 규칙
    - *     올 트래픽 0.0.0.0/0 거부
    - 아무런 서브넷과도 연결되어있지 않음

- NACL 생성 후 서브넷 연결 편집으로 원하는 서브넷에 NACL 할당
- 인바운드 규칙 - 인바운드 규칙 편집으로 원하는 규칙 추가
- 아웃바운드 규칙 - 아웃바운드 규칙 편집으로 원하는 규칙 추가

## DB, RDS(Relational Database)

- DB의 필요성
    - 어플리케이션이 하드디스크에 파일을 write하는 방식으로 데이터를 영구저장할 수 있음
    - 그러나 어플리케이션이 관리하는 데이터가 많으면 많을 수록, write 처리가 많아지며 만약 동시에 write 처리가 이루어질 경우 충돌이 날 수도 있고, 처리량이 많고 복잡하며 비직관적이고 어려움
    - 그 모든 문제를 처리하기 위한 인터페이스가 SQL을 사용하는 DB
    - DB는 데이터를 다루는 인터페이스를 제공
    - 이게 너무 유용하다보니 업계 전체가 데이터베이스를 사용하기 시작함
    - 최근에 가장 많이 사용되는 것은 관계형 데이터베이스 (RDB)와 NoSQL DB가 많이 사용됨
- 이런 데이터베이스도 설치하고, 구동하는 프로그램임
- 즉 이것도 AWS 리소스들처럼 24시간, 7일 내내 운영되어야 한다

- AWS에서 DB를 사용하는 방법
    - 우리 컴퓨터에 DB를 설치하는 것처럼 인스턴스에 DB 프로그램을 설치해도 좋음
    - 하지만 AWS에서 제공해주는 데이터베이스 설치, 자동운영, 관리, 백업과 다중화 작업도 전부 처리해주는 관리 서비스 RDS를 사용하여도 됨
    - 만약 데이터 저장 공간이 부족할 경우, RDS를 쓰지 않았다면 우리가 일일히 하드디스크 용량을 더 할당해주어야 하지만, RDS를 사용하면 얘가 알아서 데이터 더 빌려줌
- RDS를 사용하면, DB 설치나 운영 관리 전부 다 직접 해주기 때문에 우리는 DB 성능만 고르면 다 적용

- DB를 사용하는 방법
    1. 키와 값으로 이루어진 데이터를 저장하는 방식
    2. 관계형 데이터베이스 : 하나 이상의 테이블로 구성되어 행과 열로 이루어져있고, SQL 인터페이스를 통해 데이터를 읽고 쓸 수 있음
- 클라우드 환경에선 설치 필요 없이 몇 가지 설정만으로 DB실행 서버를 생성할 수 있다
- EC2 인스턴스 가상머신이 존재하고, DB가 설치되고 운영되는 RDS 인스턴스 가상머신이 따로 존재

- RDS 이용 시 고가용성 확보 방법
    - EC2 인스턴스의 고가용성 확보 방법인 ‘다중화’를 똑같이 적용 가능
    - RDS 인스턴스 역시 여러 개를 생성하여 사용자 요청을 처리해줄 수 있음
    - 이 방법을 Multi-AZ 라고 명칭함 (여러 개의 가용영역)
    - 실제 사용되고 있는 RDS 인스턴스는 Primary라고 부름
    - 예비로 동작중이며 언제든지 Primary로 전환될 수 있는 RDS 인스턴스는 Standby라고 부름

- 실제로 RDS를 생성하기 위핸 어떤 서브넷을 사용할지 정해주어야 함
- 이 서브넷들의 묶음을 Subnet Group이라고 명칭함
- 보통 DB서버는 Public에 있을 필요가 전혀 없어서, Private 서브넷을 사용함

## RDS 생성

- AWS 메뉴의 RDS로 이동
- 좌측 메뉴의 서브넷 그룹으로 이동, DB 서브넷 그룹 생성
- VPC 선택 후 사용하는 가용영역들 모두 선택, Private 서브넷들을 선택
    - 여기서 서브넷에 네임 태그가 안떠서, 직접 서브넷 ID를 대조해보고 선택해야 함
- 이후 해당 서브넷으로 이동할 수 있는 RDS에 연결할 보안그룹을 생성
- VPC 선택 후, 인바운드 규칙의 유형을 MYSQL/Aurora로 정해주면 포트가 3306으로 고정
- 이번엔 소스에 IPv4 CIDR를 넣어주는 것이 아닌, **소스에 보안그룹**을 넣어줄 것
    - 보안그룹의 소스에 보안그룹을 넣어주는 것!
- 이 의미는, **해당 보안그룹을 지니고 있는 EC2 인스턴스가 인바운드하는 것을 허용**한다는 의미
- 이제 RDS 인스턴스를 띄우고, 그 인스턴스의 보안그룹에 방금 만든 보안그룹을 할당하면 됨

- DB 생성 후 표준 생성, 엔진 옵션은 MySQL
- 템플릿은 개발/테스트
- 가용성은 다중 AZ DB 인스턴스
- DB 인스턴스 식별자는 실제로 인스턴스가 띄워질 이름
- 자격 증명 설정은 DB에 로그인할 ID와 PW를 설정하는 칸
- 인스턴스 구성은 실제로 RDS가 들어갈 가상머신을 고르는 것으로, 버스터블 클래스가 가장 쌈
- DB니까 데이터를 저장해야하므로 스토리지를 골라야 함
- 스토리지 유형은 범용 SSD, gp2
- 할당하는 스토리지는 일단 실습이니까 20GB로 조그맣게
- 스토리지 자동 조정은 용량 모자라면 알아서 늘려주는건데 일단은 체크 해제
- VPC 설정하고, DB 서브넷 그룹 선택
- 퍼블릭 액세스는 외부 인터넷에서 접근을 허용할것인가를 체크하는 것. 우선은 체크 해제
- 보안 그룹은 방금 만든 것 하나만 넣어주면 됨
- 데이터베이스 인증은 암호 인증
- 데이터베이스 옵션에서 초기 데이터베이스 이름을 작성 가능
- 자동 백업은 일단 실습이므로 빼두기
- 암호화 활성화는 DB에 저장할 때 암호화할것인지 확인하는 것. 체크해두기
    - 복호화는 RDS가 알아서 해줌
- 모니터링같은건 일단 다 끄기, 로그 내보내기도 모두 끄기 (실습이라)
- 유지관리에서 마이너 버전 자동 업그레이드 체크
- 유지 관리 기간은 기본 설정 없음
- 삭제 방지 활성화는 비활성화 (삭제할 때 한번 더 물어보는 실수 방지용)
- 여기까지 설정해두면 월별 추정 요금이 나옴

# ■ 12주차 (5월 24일)

## RDS 인스턴스 생성 후 접속 과정

1. VPC와 서브넷 일괄 생성
2. 보안그룹 SSH 프로토콜 러너랩 IP 인바운드 허용으로 생성
3. 보안그룹 HTTP 프로토콜 강의실 컴퓨터 IP 인바운드 허용으로 생성
4. 보안그룹 MySQL/Azure 프로토콜 db SSH 인바운드 허용으로 생성
5. 퍼블릭 서브넷에 Bastion Host 인스턴스 생성
6. 프라이빗 서브넷 2개를 서브넷 그룹으로 할당
7. RDS DB 인스턴스를 해당 서브넷 그룹에, db 보안그룹 할당해서 생성
8. 러너랩에서 Bastion Host 접속 후 mariadb105 인스톨 후 mysql 접속

## 블로그 웹 서버 운영

- 우리가 만들고자 하는 서버는 LAMP 서버 (LAMP Stack이 설치된 서버)
    - Linux / Apache / MySQL / PHP 프레임워크 조합
    - 지금까지 한 실습으로 Linux와 MySQL이 띄워졌다.
- 아래의 패키지들을 퍼블릭 EC2 (Bastion Host) 에 설치
    - httpd
    - php-fpm
    - php-mysqli
    - php-json
    - php
    - php-devel
    - mariadb105-server
- 이후 Apache 웹 서버 실행
    - sudo systemctl start httpd
- Apache 웹 서버 재부팅 시 자동 실행하도록 enabled 해줄 것
    - sudo systemctl enable httpd : 재부팅시 자동 실행 허용
    - sudo systemctl is-enabled httpd : 실행 여부 확인
- Apache 웹 서버 접속 확인 : 크롬 주소창에 퍼블릭 EC2 인스턴스의 퍼블릭 IP 입력
    - It works! 가 출력되면 성공
- 이제 웹 어플리케이션을 등록해야 함
- 그를 위한 환경 설정을 해줄 것
    - Apache httpd는 Apache document root라는 디렉토리에 보관된 파일을 처리
    - Amazon Linux에서 Apache anstj fnxmsms /var/www/html
    - 기본적으로 루트 사용자만이 소유
        - 이 사항을 ec2-user 계정에서도 문서 루트를 사용할 수 있도록 권한이 필요
        - Linux에 apache라는 사용자 그룹을 생성하고, 그 그룹에 권한을 부여하는 방식
- 파일 권한 설정
    1. ec2-user를 apache 그룹에 추가 (이 그룹은 기본적으로 생성되어있음)
        1. sudo usermod -a -G apache ec2-user
    2. exit로 ssh 접속 종료 후 재접속
    3. 소속 그룹 확인
        1. groups 명령어 쳤을 때 apache가 들어가있으면 성공
    4. 파일 권한 설정
        1. /var/www의 소유권을 ec2-user와 apache 그룹에게 할당
        2. sudo chown -R ec2-user:apache /var/www
        3. ls -la /var | grep www
            - www의 디렉토리 권한이 drwxr-xr-x ec2-user apache 되있으면 성공
    5. 해당 디렉토리의 하위 파일들과 생성될 파일이 기본적으로 apache 그룹에 속하도록 지정
        1. sudo chmod 2775 /var/www && find /var/www -type d -exec sudo chmod 2775 {} \;
    6. 하위 디렉토리 내의 모든 파일이 apache 그룹에 대한 쓰기 권한 부여
        1. find /var/www -type f -exec sudo chmod 0664 {} \;
- 이제 권한 설정은 완료
- 간단한 LAMP 서버 테스트를 할 것
    - Apache 문서 root 위치에 php 파일 생성
        - echo "<?php phpinfo(); ?>" > /var/www/html/phpinfo.php
    - 아래 주소로 접속 테스트
        - [http://EC2](http://EC2) 인스턴스 퍼블릭 IP/phpinfo.php
        - php 기본 문서가 생성되어 서버 접속 후 확인할 수 있는게 확인됨
- 이 문서는 보안상 노출되면 안되는 파일
    - rm /var/www/html/phpinfo.php
- Apache 웹 서버에 웹 어플리케이션 등록을 위한 설정
    - MySQL 서버 관리 도구 phpMyAdmin 설치
    - 이는 sqldeveloper과 같은 DB 관리 도구이며, 웹 브라우저를 통해 사용 가능
        - sudo dnf install php-mbstring php-xml -y
        - sudo systemctl restart httpd 로 서버 재시작
    - phpMyAdmin 설치
        - sudo systemctl restart php-fpm 로 php-fpm 다시 시작
        - cd /var/www/html 로 디렉터리 이동
        - wget [https://www.phpmyadmin.net/downloads/phpMyAdmin-latest-all-languages.tar.gz](https://www.phpmyadmin.net/downloads/phpMyAdmin-latest-all-languages.tar.gz) 최신 소스 패키지 다운로드
        - mkdir phpMyAdmin
        - tar -xvzf phpMyAdmin-latest-all-languages.tar.gz -C phpMyAdmin --strip-components 1 압축 해제
        - rm phpMyAdmin-latest-all-languages.tar.gz 설치파일 제거
    - phpMyAdmin에서 RDS에 설치된 MySQL에 접속하도록 지정
        - cd phpMyAdmin
        - cp config.sample.inc.php config.inc.php
        - vi config.inc.php 편집기를 틀어 주소 수정
        - [localhost](http://localhost) 주소를 본인 RDS 주소로 변경
            - i 눌러 수정모드로 진입하여 작성
            - shift + ; 눌러 명령모드 진입 후 wq로 저장후 종료
    - [http://퍼블릭EC2인스턴스IP/phpMyAdmin/index.php](http://44.200.239.162/phpMyAdmin/index.php)
    - 접속 시 MySQL 서버 관리 도구 phpMyAdmin 접속 확인
    - ID/PW 로그인 성공하면 목표 달성
    
- 이제 phpMyAdmin GUI로 프라이빗 서브넷에 있는 RDS를 관리할 수 있게 됨
- 이제 WordPress 블로그 웹 서버를 띄워볼 것
- EC2 인스턴스 접속 후 wordpress 다운로드
- MySQL 접속
- DB 생성 후 권한 부여
- 설정 파일 내용 수정
    - DB 정보 환경 변수의 접속 정보를 작성
    - 실사용자의 쿠키 암호화 처리를 라인 작성
    - 웹서버 문서 루트에 WordPress 파일 설치
    - conf 사용자 인증 사용을 허용으로 만들도록 수정
- 이후 공인 IP로 접속하여 회원가입
    - suldangoo
    - john200s_
- 설치 후 로그인하면 접속 성공!


# ■ 13주차 (5월 31일)

## Wordpress 블로그

- 환경이 바뀌었을 때 보안그룹 인바운드 규칙을 바꾸어주어야 함
- 우선 기본적으론 블로그 사이트만 접속되고, 관리자 페이지는 접속되지 않는 것이 정상
    - phpMyAdmin/index.php에 접속하여 wordpress-db 항목 탭
    - wp_options 탭을 눌러보면 siteurl과 home의 ip주소가 적혀있음
    - siteurl과 home의 ip주소를 EC2 인스턴스의 퍼블릭 IP로 바꾸어주면 정상적으로 블로그와 관리자 페이지, 로그인 페이지에 접속이 가능해짐
- 웹서버를 만들어서 RDS도 세팅하고, Apache 서버도 띄우고, php 서비스도 모두 만듬
- 이제 클라우드의 고가용성을 활용해 사용자 부하가 급격히 증가하더라도 정상적인 서비스를 운영할 수 있도록 ELB를 사용하여 서비스를 구축해볼 것임

## ELB (Elastic Load Balancer)

- 로드 밸런싱 (Load Balancing)
    - 네트워크 트래픽을 하나 이상의 서버나 장비로 분산하기 위해 사용되는 기술
    - 우리가 지금까지 고가용성을 확보하기 위해 사용했던 기술은 다중화
    - 다중화한 서버가 여러개인데, 그 서버에 접속하려고 모든 서버의 IP를 기억해야 하는 사태가 발생함
    - 그래서 그들을 묶어놓은 하나의 노드가 바로 **로드 밸런서**
    - 로드 밸런서의 IP만 알고 거기에 접근하면, 따로 처리하는건 없고 다중화된 서버에 트래픽을 전달해주는 역할을 수행함
    - 서비스 사용자의 요청을 서버로 분산해서 전달
- 로드 밸런서는 Public IP를 가지고 있고, 자체적인 Private IP를 가지고 있음
- 로드 밸런서에 연결된 장치들은 Public IP를 가질 필요가 없어 같은 VPC 안에 존재하므로 Private IP만 소유하고 있으면 됨
- 인터넷과 로드밸런서의 통신은 Public IP를 사용
- 로드밸런서와 장치들의 통신은 Private IP로 내부 통신을 사용

- 웹 트래픽이 증가했을 때 대응 방법엔 두 가지 방법이 존재
- Scale UP
    - 직렬적으로 인스턴스의 크기를 키우는 것
    - CPU, Memory, Network, RAM, Disk 등의 리소스 성능을 업그레이드
    - 비싸고 좋은 서버를 사용하여 많은 부하를 감당
- Scale Out (로드 밸런싱과 함께 사용)
    - 병렬적으로 부하를 처리할 서버 대수를 늘리는 것
    - 저렴한 서버 여러 대를 사용해 많은 부하를 감당
    - 생성한 서버는 계속해서 똑같은 로드 밸런서에 연결해주는 것

- 로드 밸런서가 자기 뒤에 존재하는 인스턴스에게 트래픽을 전달해주어야 함
- 어떤 방식을 사용해야 사용자의 처리를 고르게 인스턴스에게 전달할 수 있을까?
- 여러 로드 밸런싱 방식이 존재
- Round Robin
    - 로드 밸런서에서 서버 선택 시, 다음 서버를 순차적으로 선택하는 방법
    - 첫 번째 요청은 1번 서버에, 두 번째 요청은 2번 서버에…
- Hash (Sticky Session)
    - Hash는 일종의 함수 hash()
    - 이 함수에 일정한 인자값을 넣어주면 정해진 값을 리턴하는 함수
    - 즉, 똑같은 input을 넣으면 똑같은 ouput이 나옴
    - 로드 밸런서에서 서버 선택 시 클라이언트와 서버가 한 번 연결되면, 그 이후엔 항상 같은 서버로 연결함
    - 인풋엔 사용자(클라이언트)의 IP:Port와 Server:Port 등 여러가지가 들어감
    - 그랬을 때 어떤 인스턴스로 갈 지 리턴이 정해짐
    - 사용자의 로그인처럼 서버에 세션과 로그가 유지되어야 하는 환경에선 이 스티키 세션이 이루어져야 이전 로그인 정보가 사라진다거나 하는 사태가 발생하지 않음.
    - 사실 이 스틱키 세션은 Hash와는 조금 독립적인 방식으로, 위의 RR 방식에도 적용이 가능함. 로그인 후 1시간동안은 세션을 유지하라는 설정등이 가능함
- Least Connection
    - 로드 밸런서에서 서버 선택 시 가장 연결 수가 적은 서버를 선택
    - 서버마다 연결된 사용자 수를 일치시키는 것
    - 그러나 이 경우 어떤 유저는 헤비 유저고, 어떤 유저는 라이트 유저임에도 접속자 수만 가지고는 어느 서버에 부하가 가장 많은지를 알 수 없음
- Response Time (응답 시간)
    - 로드 밸런서에서 서버 선택 시, 응답속도가 가장 빠른 서버를 선택
    - 이 경우 응답 시간이 가장 빠르다면 그 인스턴스가 가장 놀고 있을 가능성이 높음
- 등등의 여러가지 방식이 있으나, 역시 가장 많이 쓰는 것은 Sticky Session을 적용시킨 RR

- 데이터가 여러 장비를 타고 타고, 환승해가며 목적지에 도착함
- 이 데이터는 패킷이라는 형태로 있으며, 보내고자 하는 데이터 뿐만 아니라 목적지까지 환승해갈 데이터를 따로 포함하고 있음
- 그 데이터들을 옆에 다닥다닥 붙여놓는데, 이 층 하나하나를 계층이라고 부름
- 이 계층들을 OSI 7 Layer 라고 호칭함
    - 물리 / 데이터링크 / 네트워크 / 전송 / 세션 / 표현 / 응용 계층이 존재
    - 세션 / 표현 / 응용 계층은 그냥 합쳐서 응용 계층 (Application Layer) 으로 합침

- 로드 밸런서라는 네트워크 장비에도 종류가 있음
- ALB (Application Load Balancer)
    - Application Layer에 속하는 패킷을 처리할 수 있음
    - HTTP / HTTPS 등의 프로토콜을 처리하는 것
    - 도메인, 리소스 위치 등을 처리
- NLB (Network Load Balancer)
    - Transport Layer에 속하는 패킷을 처리할 수 있음
    - TCP / UDP 등의 프로토콜을 처리하는 것
    - IP와 Port를 처리하는 것
- 외에 CLB 방식도 있으나 이친구는 거의 하위호환 방식으로 점점 사라지고 있음

- ELB 옵션
    - 인터넷 트래픽용
        - 인터넷에서 ELB에 접근하는 경우, 즉 Public IP를 가진 클라이언트에서 접근
        - 단, ELB가 공인IP와 사설IP를 쌍으로 가지므로, Private IP 클라이언트에서도 사용 가능
    - 내부 네트워크 트래픽용
        - 내부 네트워크에서 ELB에 접근하는 경우, 즉 Private IP를 가진 클라이언트에서 접근
        - 전용선을 통해 인터넷을 거치지 않으므로 VPC에 연결되어있는 경우에 활용
        - 혹은 VPN을 통해 Private IP로 통신하는 경우에도 활용

- ELB 동작 특징
    - 상태 확인 서비스 (Health Check)
        - ELB에서 연결할 서버들의 상태를 상시 체크
        - 비정상 서버엔 트래픽을 전달하지 않음
        - 그래서 몇몇 서버가 다운되더라도 사용자 입장에선 항상 서버가 살아있는 것으로 보임
    - 고가용성 지원 (High Availability)
        - 로드 밸런서 역시 네트워크 장비
        - 로드 밸런서를 하나만 생성해 한 서브넷에 두게 되면, 그 서버가 다운될 시 로드 밸런서도 먹통이 됨
        - 즉, 로드 밸런서 자체도 다중화를 하여 가용영역별로 만들어주어야 함
            - 근데 또 이러면 사용자들이 또또 로드밸런서 별로 IP를 다 알아야하나?
            - 이건 DNS (Domain Name Server) 가 서버를 문자로 되어있는 URL로 매핑시켜주어 해결해줌. 사용자는 문자로 된 도메인만 알아도 DNS가 IP로 바꾸어줌
            - DNS가 어떤 로드밸런서에 연결해주는가? 는 아까 공부했던 RR 등의 방식이 똑같이 적용됨. 심지어 사용자의 위치 정보(서울)를 가지고 그와 가까운 지역에 있는 IP를 할당하여 더 빠르게 접근 가능한 방식도 존재함
        - 특정 가용 영역에 문제가 발생하더라도 다른 가용 영역의 ELB가 트래픽을 처리

## 실제로 ELB를 활용한 서버 구축

- 로드 밸런서를 만들기
- 로드 밸런서가 인스턴스에 트래픽을 전달할 수 있도록 만들기
- 새로운 서버를 하나 만들어서 로드 밸런서에게 추가해주기
    - 새로운 서버를 만들기 위해, AMI를 활용해 서버 복제하기

- 보안그룹 할당 및 설정하기
1. ALB와 연결할 보안 그룹을 새로 생성하기
    1. 로컬 PC가 인바운드 규칙에 추가된 보안 그룹 생성
    2. 아웃바운드는 모든 트래픽 허용
2. ALB에서 인스턴스로 갈 수 있는 보안 그룹을 새로 생성하기
    1. 인바운드 규칙을 바로 위에서 만든 ALB보안그룹으로 추가
3. wordpress db의 인바운드 규칙을 편집
    1. DB 인스턴스로 갈 수 있는 인바운드 규칙을 기존 인터넷 직행에서 로드밸런서를 거쳐야 갈 수 있도록 루트를 편집한 것
4. 인스턴스에 server form alb 보안 그룹을 추가하여 총 3개의 보안 그룹이 할당되도록 수정
5. 접속 테스트
    1. http://인스턴스공인IP/wp-admin/
    
- 로드 밸런서 (ALB) 생성
1. 로드 밸런서가 트래픽을 전달해줄 대상인, 타겟 그룹을 생성해야 함
    1. EC2 관리콘솔 가장 아래의 Target groups 선택
    2. 기본 구성은 기본적으로 인스턴스이나, IP나 람다 함수나 두 번째 로드밸런서도 가능
    3. 타겟 그룹의 프로토콜과 포트를 입력 (HTTP, 80)
    4. VPC 선택하고 프로토콜 버전은 HTTP1
    5. Health check 프로토콜을 HTTP로 두고, 상태 검사 경로는 기본 경로인 최상위경로 ‘/’
    6. 상태 검사 설정으로 가서 상태 검사를 할 간격 (Interval) 을 10초로 짧게 지정
    7. 성공 코드가 200 OK를 떨구면 생존 확인이 된 것
    8. 생성 후 보류중인 것으로 포함 클릭시 대상 그룹 생성이 되었으므로 목록이 나타남
2. Sticky Session이 되도록 대상 그룹에 설정
    1. 대상 그룹의 속성 - 편집 클릭
    2. Target configuration (대상 그룹 등록 지연) 을 10초로 줄여두기
    3. 로드 밸런싱 알고리즘은 라운드 로빈 그대로
    4. Target selection configuration에서 고정 (Stickness)를 체크
    5. 로드 밸런서 생성 쿠키 방식으로, 지속 시간은 1시간
3. 이제 타겟 그룹에 할당해줄 로드 밸런서를 생성
    1. 로드 밸런서 항목의 로드 밸런서 생성 클릭
    2. ALB와 NLB가 존재 (GLB는 좀 특이함) 우리는 ALB를 사용할 것
    3. 인터넷 - 로드밸런서 전용이므로 스키마는 Internet-facing으로 체크
    4. IPv4 주소 타입에 VPC의 모든 가용 영역을 지정
    5. 로드 밸런서는 인터넷과 연결되어 있어야 하므로 public 서브넷으로 매핑
    6. 보안 그룹은 wordpress-alb만 해놓고 기본은 삭제
    7. 리스너는 이 로드 밸런서에 들어온 HTTP 80 번 포트로 들어온 요청은 넘겨준다는 작업을 설정해주는 것. 기본 작업을 wordpress-server 인스턴스로 지정해주면 완성
4. 로드밸런서가 생성되었다면, 해당 로드밸런서의 DNS name을 복사해서 URL에 넣어주면 블로그에 접속되는 화면을 확인할 수 있음

- AMI를 생성하여 인스턴스 복제
1. 복제를 위한 사전 작업으로 Wordpress URL 정보를 변경한다
    1. Wordpress CLI 다운받고 접속 주소가 IP가 아닌 도메인이 되도록 설정 변경 명령어 입력
    2. n개의 정보가 replacements 되었다고 뜨면 성공
2. 기존의 EC2 AMI 이미지 생성
    1. 작업 - 이미지 및 템플릿 생성 클릭
    2. 이름과 태그만 바꿔주고 생성

- NAT GateWay 2개만 삭제하여 요금 절약