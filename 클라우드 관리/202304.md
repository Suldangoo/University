# ■ 5주차 (4월 5일)

- touch 명령어로 빈 파일을 생성할 수 있음
    - touch ebs.txt
- echo와 redirection 명령어로 파일을 생성할 수 있음
    - echo “ebs” > instance_store.txt

- echo : 인자로 받은 문자열을 printf로 출력하는 프로그램
- redirection : 우선 일반적인 명령어, 애플리케이션, 프로그램이 아닌 리눅스의 기능임. 인자로 받은 값을 다른 프로그램의 인자로 전달하는 기능으로, > 명령어로 쓸 수 있음
- touch : 파일의 생성 시간을 변경하거나 새로운 파일을 생성하는 프로그램
    - 이미 존재하는 파일을 인자로 주었을 땐 파일의 수정 시간을 현재 시간으로 변경

- 서비스를 시작한 후 사용을 하다 보면 모든 스토리지 용량이 전부 차게 될 수 있음, 이렇게 될 경우 서비스가 중단될 수 있다
- 그럴 경우 기존 파일을 삭제할 수 있지만 기존 파일을 삭제하지 못하는 경우 디스크 볼륨을 추가할 수 있다
- AWS EC2탭의 Elastic Block Store - 볼륨 탭으로 이동
- 스토리지의 동작 원리는 논리적 볼륨 생성 - 파일 시스템 추가 - 가용 시작
- 별도로 설정할 건 없고, 용량만 우리가 정해주면 됨
- 단, 가용 영역이라는 메뉴가 있는데 이것은 ‘어떤 데이터 센터’에 있는 볼륨을 쓸 지 선택까지 해야함
    - 이 경우 EC2 인스턴스의 데이터 센터와 맞는 **가용 영역**에 맞게 추가해주어야 함
- 볼륨 생성 후 일정 시간이 지나면 사용 가능 상태가 되며, 작업 - 볼륨 연결로 볼륨 추가가 가능
- 인스턴스에 연결했으면 그 상태에서 바로 lsblk 사용해보면 새 블록이 할당된 걸 볼 수 있음
- 리눅스의 파일 시스템에 따라 디스크 볼륨을 특정 디렉토리에 연결해야 함
    - 파일 시스템 생성은 다음과 같은 명령어로 가능
        - sudo mkfs.ext4 /dev/xvdf
        - mkfs → make file system
        - ext4 → 가장 빈번하게 사용되는 파일 시스템들 중 하나
        - 어디다가 만들거냐? → /dev/xvdf
        - 그러나 이 명령어는 일반 사용자로는 실행이 되지 않아 sudo로 실행해야 함
    - 파일 시스템을 생성했다면 디렉토리에 연결해야 하며, mount 명령어를 사용
        - 디스크 볼륨에 생성된 파일 시스템을 디렉토리에 마운트하는 명령어
        - mkdir test
        - sudo mount /dev/xvdf test
        - logout 후 위 명령어를 실행하면 홈 사용자 디렉토리 아래에 생성된 디렉토리가 아까 만든 볼륨을 차지하는 디렉토리로 생성이 됨
- 이후 이 볼륨을 분리 후 삭제하려고 하면, 볼륨 분리가 되지 않음. 왜냐하면 mount가 된 디스크 볼륨은 뜯을 수가 없기 때문임
- 볼륨을 분리하는 명령어는 unmount
    - sudo umount /dev/xvdf
- 이후엔 AWS 볼륨 분리가 가능해짐
- 볼륨이 분리되면 다시 사용 가능 상태로 전환되며, 볼륨 삭제를 눌러 데이터 센터에 스토리지를 반납할 수 있음
- 정말 중요한건, 이 모든 과정이 **서비스 중단 없이 인스턴스가 동작중인 상태에서 가능**하다는 점이다

## 5주차 수업

- 우리의 최종 목표는 three-tier 형태로 서버를 구축해보는 것
- three-tier 형태로 AWS환경에 서버를 구축하기 위해선 PHP와 Apache를 설치할 줄 알아야 하며, 이는 모두 리눅스 명령어를 숙지해야하만 가능한 환경 구축이다.
- 하여 소프트웨어를 설치하고 관리 및 운영을 하면 로그(log)가 남으며, 해당 로그를 읽고 관리할 수 있도록 연습하여야 한다.

- 이번 수업 시간엔 인스턴스 유형을 포함한 키 페어, 고급 세부 정보를 건드려볼 것

- EC2에서 컴퓨팅 자원 배포는 다음과 같이 이루어진다.
    - SW와 OS는 AMI로 미리 설치할 수 있다
    - CPU와 Memory, Network는 인스턴스 타입에 따라 성능이 결정된다
    - Storage는 물리서버로 EBS에서 네트워크로 독립적인 연결로 이루어진다

## 인스턴스 유형 수직 확장 (Scale-up)

- 지금까지는 인스턴스 타입을 변경할 때 인스턴스를 종료하고 새로 만들었으나, 중지 상태에서 기존에 사용중인 EC2 인스턴스의 타입을 더 높은 성능으로 갈아끼울 수 있다
- 이를 **수직 확장(Scale-up)**이라고 부른다.
- 인스턴스 개수를 늘려 가용성을 늘리는 것은 **수평 확장(Scale-out)**이라고 부른다.

- 원래 지금까지는 원격 연결을 하려면 키페어 방식으로 ppk 파일을 다운받아서 연결했으나, 이 키페어 파일이 유출되면 큰일나는 방식이었다
- 그러나 인스턴스 항목에서 원하는 인스턴스를 선택한 후 ‘연결’을 누르면 키페어 없이 브라우저에서 바로 CUI 환경을 가용시킬 수 있다

- 인스턴스를 수직 확장하고 싶다면, 우선 인스턴스를 중지해야 함
    - 즉, 만약 서비스가 이미 진행중인데 수직 확장을 하려면 인스턴스를 중지해야 하므로 사용자들에게 피해가 가는 것은 어쩔 수 없음
    - 이것은 2개 이상의 인스턴스를 만들어 ‘다중화’를 해야하고, 한 인스턴스가 종료되었을 때 사용자의 입력 처리를 다른 인스턴스에 받는 것임. 이를 ‘롤링 업데이트’라고 부름
    - 우선 지금은 1대만 가지고 실습
- 중지됨 상태가 되면 인스턴스 선택 후 작업 - 인스턴스 설정 - 인스턴스 유형 변경 선택
- 여기서 원하는 인스턴스를 선택하고 확인하면 인스턴스 유형을 변경할 수 있게 됨

## 키 페어 생성 및 사용

- 네트워크 및 보안 메뉴에서 키 페어 탭에 들어가야 함
- 들어가면 vockey 하나가 기본적으로 존재하며, 키 페어는 사실 암호화를 위한 무작위 긴 문자열
- 키 페어 생성 시 키 페어의 이름과 여러가지 설정을 할 수 있음
    - 키 페어 유형 : 암호화를 하는 방법 선택
    - 암호화 알고리즘들 중 가장 보편적인 알고리즘 하나가 RSA 알고리즘
    - 서버에는 퍼블릭 키가 있고, 우리는 프라이빗 키를 가지고 있음
        - pem파일은 리눅스 환경에서 OpenSSH와 함께 사용
        - ppk파일은 윈도우 환경에서 Putty와 함께 사용
        - 내용 자체는 똑같고 파일의 포맷이 달라지는 것, 파일을 파싱할 때 어떤 형식인지 알아야 각 프로그램에 맞게 해석할 수 있는 것
- 이렇게 키페어를 생성했다면 인스턴스 생성할 때 원하는 키페어를 선택할 수 있음
- 단, 이 키 페어 파일이 유출되어 해킹을 당하면 우리의 관리가 부실했던 것이므로 우리의 책임

## 사용자 데이터

- 사용자 데이터는 윈도우로 따지면 ‘시작 프로그램’
- 인스턴스 시작 시 자동으로 실행되는 스크립트를 지정하는 것이며, 코딩으로 직접 환경을 지정 가능
- 스크립트(Bash, PowerShell)를 사용하여 인스턴스의 런타임 환경을 지정 가능
    - 단, 기본적으로는 인스턴스가 최초로 시작될 때 한 번만 스크립트가 실행됨
- AMI를 만들 필요 없이 사용자 데이터를 실행해 초기 환경을 구성하는 것이 가능
    - 사용자 데이터에 yum 명령어와 함께 무언가를 설치하는 것이 가능하다는 것
    - yum 명령어는 프로그램을 설치할 수 있는 패키지 관리자 명령어
- 인스턴스를 생성할 때 다른 부분은 그대로 두고, 고급 세부 정보 칸의 사용자 데이터에 원하는 스크립트를 입력하는 것
- 사용자 데이터에서 명령어 인자로 경로를 지정할 땐, 반드시 절대경로로 명시를 해주어야 함.
    - 사용자 데이터 스크립트는 루트 사용자 권한으로 실행되기 때문
- 리다이렉션엔 여러가지 방법이 존재
    - ‘>>’ : 특정 명령의 실행 결과를 파일에 쓰는데, 기존 내용의 다음 줄에 쓰게 됨
    - ‘>’ : 특정 명령의 실행 결과를 파일에 아예 덮어씌워버림 (overwrite)
- **예상 시험 문제 (리눅스 명령어)**
    - 다음 명령어의 실행 결과를 쓰시오
    - 다음 실행 결과를 수행할 명령어가 무엇인가

## 파이썬으로 심플 웹서버 실행

- 인스턴스 생성 시 네트워크 설정에서 ‘인터넷에서 HTTP 트래픽 허용’ 체크
- 아래와 같은 명령어 실행

```livescript
sudo mkdir -p /var/www/html
cd /var/www/html
sudo python3 -m http.server 80
```

- 위 경로는 html 웹 서버를 열 때 가장 보편적으로 사용되는 디렉토리 경로
- HTTP 서버는 기본적으로 80번 포트를 사용

## 리소스 관리

- 리소스(Resource)
    - 사용자가 생성하거나 AWS 서비스를 통해 자동으로 생성되는 모든 가상 자원
    - 예를 들어 EC2 인스턴스, EBS, 보안 그룹 (방화벽), 키 페어 등등…

- ARN(Amazon Resource Name)
    - 리소스를 구분하기 위한 유일한 식별자 (Identify)
    - 리소스를 생성하는 시점에 이미 결정이 됨
    - ARN의 구성, 형식은 아래와 같음
        - 서비스명
        - 리전(Region) : AWS의 데이터 센터가 위치한 지역
        - AWS 계정 ID
        - 리소스 유형 (Type)
        - 리소스 ID
        - 선택적인 추가 구성 요소
        
- 리소스의 리전(Region)은 데이터 센터가 존재하는 물리적 위치인데, 아카데미의 경우엔 버지니아 북부로 설정되어있으며 대한민국 서울은 아카데미 ID로는 권한이 없음
- ARN 정보만으로는 그 리소스가 어떤 역할이고 무슨 기능을 수행하는지 구별하기엔 어려움
- 그러나 태그(Tag)를 보면 리소스가 어떤 역할을 수행하는지 확인할 수 있음
    - 키와 값으로 구성되어 있음 (키는 필수, 값은 선택)
    - 태깅은 EC2 인스턴스에 의미와 정보를 부여
    - 태그가 없으면 어떤 사용자가 어떤 목적으로 인스턴스를 사용하는지 확인이 어려움
    - 마치 주석같은 존재
- 태깅의 장점
    - 필터링 : 원하는 태그의 리소스들만 선택하여 일괄적인 작업 수행
    - 자동화
    - 비용 할당
    - 액세스 제어
- 보안 그룹 탭에서 원하는 보안 그룹의 태그 관리 - 태그 설정으로 해당 보안 그룹이 어떤 역할이고 어떤 태그가 붙어있는지 확인할 수 있음
- 그러나 또 막상 인스턴스 생성할 때 보안 그룹 선택할 땐 태그 네임이 뜨지 않아 아쉽긴 함
    - 그래서 자동생성 보안 그룹 말고 직접 생성할 때 보안 그룹 이름을 태그의 Name과 동일하게 작명하여 구별을 쉽게 함

- 이후 Resource Groups 서비스에 들어가 새로운 그룹을 생성하면, 태그 키와 태그 값에 우리가 입력해두었던 태그가 자동으로 뜸
- 해당 태그를 설정하고 리소스 그룹을 만들면 해당 그룹에 들어가있는 모든 리소스를 일괄적으로 관리할 수 있음. 이걸 목적으로 태깅을 하는 것
- EC2는 수많은 서비스들 중 하나일 뿐. AWS계정 하나에 제공하는 200개 이상의 수많은 서비스 사용 가능
- 이 서비스들은 대부분 리눅스와 매우 유사하며, IAM(Identity and Access Management) 서비스를 통해 사용자 관리 가능
    - IAM을 통해 다양한 사용자를 만들어 ID와 PW를 통해 로그인 시킬 수 있으며, 사용자에 따라 서비스 사용에 대한 권한을 다르게 설정할 수 있음
    - 우리는 ec2-user라는 IAM 사용자로서 활동중임
- AWS 계정 이름을 보면 abc@123-456… 형식으로 명명되어있음
    - 골뱅이 앞의 내용은 유저의 ID
    - 골뱅이 뒤의 내용은 AWS 계정 아이디
- 루트 어카운트는 정말 필요할 때만 사용하고, 대부분은 ec2-user같은 IAM 사용자로 로그인하여 사용
- IAM사용자에 따라 AWS 서비스를 다루기 위한 권한이 다르다.
    - 예를 들어 어떤 사용자는 EC2 인스턴스 실행, EC2 인스턴스 중지 작업은 가능하지만 EC2 인스턴스 종료는 할 수 없게 권한을 설정할 수 있음
    - 우리 아카데미 환경에선 AWS academy에서 주어진 권한만 사용 가능함. 우리가 실제로 AWS 계정을 만들어 쓰게 되면 사용자에 대한 권한을 직접 설정할 수 있음
    
- IAM 역할 (Role)
    - 서비스에서 생성한 리소스가 직접 권한을 가지고 액션을 취할 수도 있다.
    - 즉, 사용자가 보유중인 권한으로 사용자가 원하는 액션을 취하는 것이 아닌 EC2 인스턴스에게 무언가 권한을 주고 그 리소스가 액션을 취하게 한 뒤 결과물을 사용자가 볼 수도 있다
    - 이런 리소스 자체에 권한이 주어진 것을 IAM 역할이라고 함
    - 즉, 리소스에게 마치 사람처럼 권한을 주고 원하는 액션을 취하게 할 수 있는 것
    - 예약을 걸어두면 원하는 동작을 자동으로 실행할 수 있다
        - 즉, 사람이 직접 로그인하지 않아도 리소스들한테 권한 주고 다 시켜놓으면 약속된 작업들을 자동적으로 수행할 수 있게 함