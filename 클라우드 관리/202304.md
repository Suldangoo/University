# ■ 5주차 (4월 5일)

- touch 명령어로 빈 파일을 생성할 수 있음
    - touch ebs.txt
- echo와 redirection 명령어로 파일을 생성할 수 있음
    - echo “ebs” > instance_store.txt

- echo : 인자로 받은 문자열을 printf로 출력하는 프로그램
- redirection : 우선 일반적인 명령어, 애플리케이션, 프로그램이 아닌 리눅스의 기능임. 인자로 받은 값을 다른 프로그램의 인자로 전달하는 기능으로, > 명령어로 쓸 수 있음
- touch : 파일의 생성 시간을 변경하거나 새로운 파일을 생성하는 프로그램
    - 이미 존재하는 파일을 인자로 주었을 땐 파일의 수정 시간을 현재 시간으로 변경

- 서비스를 시작한 후 사용을 하다 보면 모든 스토리지 용량이 전부 차게 될 수 있음, 이렇게 될 경우 서비스가 중단될 수 있다
- 그럴 경우 기존 파일을 삭제할 수 있지만 기존 파일을 삭제하지 못하는 경우 디스크 볼륨을 추가할 수 있다
- AWS EC2탭의 Elastic Block Store - 볼륨 탭으로 이동
- 스토리지의 동작 원리는 논리적 볼륨 생성 - 파일 시스템 추가 - 가용 시작
- 별도로 설정할 건 없고, 용량만 우리가 정해주면 됨
- 단, 가용 영역이라는 메뉴가 있는데 이것은 ‘어떤 데이터 센터’에 있는 볼륨을 쓸 지 선택까지 해야함
    - 이 경우 EC2 인스턴스의 데이터 센터와 맞는 **가용 영역**에 맞게 추가해주어야 함
- 볼륨 생성 후 일정 시간이 지나면 사용 가능 상태가 되며, 작업 - 볼륨 연결로 볼륨 추가가 가능
- 인스턴스에 연결했으면 그 상태에서 바로 lsblk 사용해보면 새 블록이 할당된 걸 볼 수 있음
- 리눅스의 파일 시스템에 따라 디스크 볼륨을 특정 디렉토리에 연결해야 함
    - 파일 시스템 생성은 다음과 같은 명령어로 가능
        - sudo mkfs.ext4 /dev/xvdf
        - mkfs → make file system
        - ext4 → 가장 빈번하게 사용되는 파일 시스템들 중 하나
        - 어디다가 만들거냐? → /dev/xvdf
        - 그러나 이 명령어는 일반 사용자로는 실행이 되지 않아 sudo로 실행해야 함
    - 파일 시스템을 생성했다면 디렉토리에 연결해야 하며, mount 명령어를 사용
        - 디스크 볼륨에 생성된 파일 시스템을 디렉토리에 마운트하는 명령어
        - mkdir test
        - sudo mount /dev/xvdf test
        - logout 후 위 명령어를 실행하면 홈 사용자 디렉토리 아래에 생성된 디렉토리가 아까 만든 볼륨을 차지하는 디렉토리로 생성이 됨
- 이후 이 볼륨을 분리 후 삭제하려고 하면, 볼륨 분리가 되지 않음. 왜냐하면 mount가 된 디스크 볼륨은 뜯을 수가 없기 때문임
- 볼륨을 분리하는 명령어는 unmount
    - sudo umount /dev/xvdf
- 이후엔 AWS 볼륨 분리가 가능해짐
- 볼륨이 분리되면 다시 사용 가능 상태로 전환되며, 볼륨 삭제를 눌러 데이터 센터에 스토리지를 반납할 수 있음
- 정말 중요한건, 이 모든 과정이 **서비스 중단 없이 인스턴스가 동작중인 상태에서 가능**하다는 점이다

## 5주차 수업

- 우리의 최종 목표는 three-tier 형태로 서버를 구축해보는 것
- three-tier 형태로 AWS환경에 서버를 구축하기 위해선 PHP와 Apache를 설치할 줄 알아야 하며, 이는 모두 리눅스 명령어를 숙지해야하만 가능한 환경 구축이다.
- 하여 소프트웨어를 설치하고 관리 및 운영을 하면 로그(log)가 남으며, 해당 로그를 읽고 관리할 수 있도록 연습하여야 한다.

- 이번 수업 시간엔 인스턴스 유형을 포함한 키 페어, 고급 세부 정보를 건드려볼 것

- EC2에서 컴퓨팅 자원 배포는 다음과 같이 이루어진다.
    - SW와 OS는 AMI로 미리 설치할 수 있다
    - CPU와 Memory, Network는 인스턴스 타입에 따라 성능이 결정된다
    - Storage는 물리서버로 EBS에서 네트워크로 독립적인 연결로 이루어진다

## 인스턴스 유형 수직 확장 (Scale-up)

- 지금까지는 인스턴스 타입을 변경할 때 인스턴스를 종료하고 새로 만들었으나, 중지 상태에서 기존에 사용중인 EC2 인스턴스의 타입을 더 높은 성능으로 갈아끼울 수 있다
- 이를 **수직 확장(Scale-up)**이라고 부른다.
- 인스턴스 개수를 늘려 가용성을 늘리는 것은 **수평 확장(Scale-out)**이라고 부른다.

- 원래 지금까지는 원격 연결을 하려면 키페어 방식으로 ppk 파일을 다운받아서 연결했으나, 이 키페어 파일이 유출되면 큰일나는 방식이었다
- 그러나 인스턴스 항목에서 원하는 인스턴스를 선택한 후 ‘연결’을 누르면 키페어 없이 브라우저에서 바로 CUI 환경을 가용시킬 수 있다

- 인스턴스를 수직 확장하고 싶다면, 우선 인스턴스를 중지해야 함
    - 즉, 만약 서비스가 이미 진행중인데 수직 확장을 하려면 인스턴스를 중지해야 하므로 사용자들에게 피해가 가는 것은 어쩔 수 없음
    - 이것은 2개 이상의 인스턴스를 만들어 ‘다중화’를 해야하고, 한 인스턴스가 종료되었을 때 사용자의 입력 처리를 다른 인스턴스에 받는 것임. 이를 ‘롤링 업데이트’라고 부름
    - 우선 지금은 1대만 가지고 실습
- 중지됨 상태가 되면 인스턴스 선택 후 작업 - 인스턴스 설정 - 인스턴스 유형 변경 선택
- 여기서 원하는 인스턴스를 선택하고 확인하면 인스턴스 유형을 변경할 수 있게 됨

## 키 페어 생성 및 사용

- 네트워크 및 보안 메뉴에서 키 페어 탭에 들어가야 함
- 들어가면 vockey 하나가 기본적으로 존재하며, 키 페어는 사실 암호화를 위한 무작위 긴 문자열
- 키 페어 생성 시 키 페어의 이름과 여러가지 설정을 할 수 있음
    - 키 페어 유형 : 암호화를 하는 방법 선택
    - 암호화 알고리즘들 중 가장 보편적인 알고리즘 하나가 RSA 알고리즘
    - 서버에는 퍼블릭 키가 있고, 우리는 프라이빗 키를 가지고 있음
        - pem파일은 리눅스 환경에서 OpenSSH와 함께 사용
        - ppk파일은 윈도우 환경에서 Putty와 함께 사용
        - 내용 자체는 똑같고 파일의 포맷이 달라지는 것, 파일을 파싱할 때 어떤 형식인지 알아야 각 프로그램에 맞게 해석할 수 있는 것
- 이렇게 키페어를 생성했다면 인스턴스 생성할 때 원하는 키페어를 선택할 수 있음
- 단, 이 키 페어 파일이 유출되어 해킹을 당하면 우리의 관리가 부실했던 것이므로 우리의 책임

## 사용자 데이터

- 사용자 데이터는 윈도우로 따지면 ‘시작 프로그램’
- 인스턴스 시작 시 자동으로 실행되는 스크립트를 지정하는 것이며, 코딩으로 직접 환경을 지정 가능
- 스크립트(Bash, PowerShell)를 사용하여 인스턴스의 런타임 환경을 지정 가능
    - 단, 기본적으로는 인스턴스가 최초로 시작될 때 한 번만 스크립트가 실행됨
- AMI를 만들 필요 없이 사용자 데이터를 실행해 초기 환경을 구성하는 것이 가능
    - 사용자 데이터에 yum 명령어와 함께 무언가를 설치하는 것이 가능하다는 것
    - yum 명령어는 프로그램을 설치할 수 있는 패키지 관리자 명령어
- 인스턴스를 생성할 때 다른 부분은 그대로 두고, 고급 세부 정보 칸의 사용자 데이터에 원하는 스크립트를 입력하는 것
- 사용자 데이터에서 명령어 인자로 경로를 지정할 땐, 반드시 절대경로로 명시를 해주어야 함.
    - 사용자 데이터 스크립트는 루트 사용자 권한으로 실행되기 때문
- 리다이렉션엔 여러가지 방법이 존재
    - ‘>>’ : 특정 명령의 실행 결과를 파일에 쓰는데, 기존 내용의 다음 줄에 쓰게 됨
    - ‘>’ : 특정 명령의 실행 결과를 파일에 아예 덮어씌워버림 (overwrite)
- **예상 시험 문제 (리눅스 명령어)**
    - 다음 명령어의 실행 결과를 쓰시오
    - 다음 실행 결과를 수행할 명령어가 무엇인가

## 파이썬으로 심플 웹서버 실행

- 인스턴스 생성 시 네트워크 설정에서 ‘인터넷에서 HTTP 트래픽 허용’ 체크
- 아래와 같은 명령어 실행

```livescript
sudo mkdir -p /var/www/html
cd /var/www/html
sudo python3 -m http.server 80
```

- 위 경로는 html 웹 서버를 열 때 가장 보편적으로 사용되는 디렉토리 경로
- HTTP 서버는 기본적으로 80번 포트를 사용

## 리소스 관리

- 리소스(Resource)
    - 사용자가 생성하거나 AWS 서비스를 통해 자동으로 생성되는 모든 가상 자원
    - 예를 들어 EC2 인스턴스, EBS, 보안 그룹 (방화벽), 키 페어 등등…

- ARN(Amazon Resource Name)
    - 리소스를 구분하기 위한 유일한 식별자 (Identify)
    - 리소스를 생성하는 시점에 이미 결정이 됨
    - ARN의 구성, 형식은 아래와 같음
        - 서비스명
        - 리전(Region) : AWS의 데이터 센터가 위치한 지역
        - AWS 계정 ID
        - 리소스 유형 (Type)
        - 리소스 ID
        - 선택적인 추가 구성 요소
        
- 리소스의 리전(Region)은 데이터 센터가 존재하는 물리적 위치인데, 아카데미의 경우엔 버지니아 북부로 설정되어있으며 대한민국 서울은 아카데미 ID로는 권한이 없음
- ARN 정보만으로는 그 리소스가 어떤 역할이고 무슨 기능을 수행하는지 구별하기엔 어려움
- 그러나 태그(Tag)를 보면 리소스가 어떤 역할을 수행하는지 확인할 수 있음
    - 키와 값으로 구성되어 있음 (키는 필수, 값은 선택)
    - 태깅은 EC2 인스턴스에 의미와 정보를 부여
    - 태그가 없으면 어떤 사용자가 어떤 목적으로 인스턴스를 사용하는지 확인이 어려움
    - 마치 주석같은 존재
- 태깅의 장점
    - 필터링 : 원하는 태그의 리소스들만 선택하여 일괄적인 작업 수행
    - 자동화
    - 비용 할당
    - 액세스 제어
- 보안 그룹 탭에서 원하는 보안 그룹의 태그 관리 - 태그 설정으로 해당 보안 그룹이 어떤 역할이고 어떤 태그가 붙어있는지 확인할 수 있음
- 그러나 또 막상 인스턴스 생성할 때 보안 그룹 선택할 땐 태그 네임이 뜨지 않아 아쉽긴 함
    - 그래서 자동생성 보안 그룹 말고 직접 생성할 때 보안 그룹 이름을 태그의 Name과 동일하게 작명하여 구별을 쉽게 함

- 이후 Resource Groups 서비스에 들어가 새로운 그룹을 생성하면, 태그 키와 태그 값에 우리가 입력해두었던 태그가 자동으로 뜸
- 해당 태그를 설정하고 리소스 그룹을 만들면 해당 그룹에 들어가있는 모든 리소스를 일괄적으로 관리할 수 있음. 이걸 목적으로 태깅을 하는 것
- EC2는 수많은 서비스들 중 하나일 뿐. AWS계정 하나에 제공하는 200개 이상의 수많은 서비스 사용 가능
- 이 서비스들은 대부분 리눅스와 매우 유사하며, IAM(Identity and Access Management) 서비스를 통해 사용자 관리 가능
    - IAM을 통해 다양한 사용자를 만들어 ID와 PW를 통해 로그인 시킬 수 있으며, 사용자에 따라 서비스 사용에 대한 권한을 다르게 설정할 수 있음
    - 우리는 ec2-user라는 IAM 사용자로서 활동중임
- AWS 계정 이름을 보면 abc@123-456… 형식으로 명명되어있음
    - 골뱅이 앞의 내용은 유저의 ID
    - 골뱅이 뒤의 내용은 AWS 계정 아이디
- 루트 어카운트는 정말 필요할 때만 사용하고, 대부분은 ec2-user같은 IAM 사용자로 로그인하여 사용
- IAM사용자에 따라 AWS 서비스를 다루기 위한 권한이 다르다.
    - 예를 들어 어떤 사용자는 EC2 인스턴스 실행, EC2 인스턴스 중지 작업은 가능하지만 EC2 인스턴스 종료는 할 수 없게 권한을 설정할 수 있음
    - 우리 아카데미 환경에선 AWS academy에서 주어진 권한만 사용 가능함. 우리가 실제로 AWS 계정을 만들어 쓰게 되면 사용자에 대한 권한을 직접 설정할 수 있음
    
- IAM 역할 (Role)
    - 서비스에서 생성한 리소스가 직접 권한을 가지고 액션을 취할 수도 있다.
    - 즉, 사용자가 보유중인 권한으로 사용자가 원하는 액션을 취하는 것이 아닌 EC2 인스턴스에게 무언가 권한을 주고 그 리소스가 액션을 취하게 한 뒤 결과물을 사용자가 볼 수도 있다
    - 이런 리소스 자체에 권한이 주어진 것을 IAM 역할이라고 함
    - 즉, 리소스에게 마치 사람처럼 권한을 주고 원하는 액션을 취하게 할 수 있는 것
    - 예약을 걸어두면 원하는 동작을 자동으로 실행할 수 있다
        - 즉, 사람이 직접 로그인하지 않아도 리소스들한테 권한 주고 다 시켜놓으면 약속된 작업들을 자동적으로 수행할 수 있게 함

# ■ 6주차 (4월 12일)

- 우리는 IAM 사용자로서 로그인하여 EC2 인스턴스를 다루고 있고, 이와 관련된 어떠한 행동을 해도 반드시 이 사용자가 권한을 가지고 있는지 한번 체크를 한다.
- 그러나 AWS가 생성한 리소스에도 권한을 부여할 수 있고, 역할을 수행하게 할 수 있으며 이 것을 IAM 역할이라고 한다.
- aws ec2 describe-instances 명령어로 EC2 인스턴스 명령 조회를 할 수 있다.
    - 그러나 당장 이 명령어는 우리가 권한이 없어 실행할 수 없다.
- IAM 역할을 할당시켜주기 위해선 인스턴스 선택 후 작업 - IAM 역할 수정을 선택하면 된다.
    - 그러나 우선 러너 랩 환경에선 쓸 수 있는 IAM 역할은 몇 개가 미리 할당되어있다. 우리가 후에 직접 계정을 생성해 쓰면 여러가지 권한이 정말 많음.
- 역할을 할당해주고 다시 위의 명령어를 쓰면 명령어가 써지는 것을 확인할 수 있다.
- 사용자 데이터로 위 명령어를 원하는 파일에 써두는 것을 미리 작성할 수 있으며, IAM 역할은 인스턴스를 생성할 때 IAM instance profile에서 미리 체크해두고 생성할 수 있다.

## 네트워크 기본 개념

- three-tier 아키텍처로 AWS 환경을 구축하려면 클라이언트와 서버를 연결하는 부분을 우리가 만들어야 함
- **네트워크** : 컴퓨터와 컴퓨터 사이를 연결하여 서로 통신할 수 있게 되는 것
- 네트워크를 구축하는 방법
    - 물리적으로 두 PC간의 케이블을 연결한다. (LAN 케이블)
        - 그러나 이 방법은 통신해야하는 컴퓨터를 늘릴 때마다 물리적인 연결을 계속해서 늘려줘야 해서 매우 복잡해진다. 이랬다간 컴퓨터 10개만 되어도 선이 너무 많아진다.
        - 그러나 컴퓨터 사이를 연결하는 중간 장치를 두게 되면 각 컴퓨터당 하나의 연결만 해도 되긴 한다.
    - 이제 중간 장치로 연결한 여러 PC들의 집합 두 개를 연결하기 위해선, **중간 장치들끼리**를 서로 연결해주어야 한다.
        - 그럼 여기서 또 네트워크가 더 증가하게 되면 **중간 장치들을 위한 중간 장치**를 놓게 된다.
    - 그럼 또 이 중간 장치들을 위한 중간 장치를 연결하는 중간 장치를…
    - 아무튼 이런 형식으로 네트워크가 구축된다.
    - 이렇게 건너고 건너고 건너가서 내 PC와 AWS의 EC2 인스턴스와 연결하게 된다.
- 인터넷 : (inter : ~사이에) 작은 네트워크들을 서로 간에 연결하여 거대한 전 세계 규모의 네트워크를 구성하는 것
- 인트라넷 : (intra : ~내부에) 특정 집단에서만 사용하는 독립적인 내부 네트워크. 허가 받은 사용자만 접근 가능하며, 인트라넷은 인터넷과 연결되어있을 수도 있으나, 연결되어있지 않을 수도 있음

- 그럼 여기서, 목적지 컴퓨터로 가기 위해선 대체 어디에 있는지 어떻게 알며, 어떻게 가야하나?
- 우리 현실 세계에선 택배를 보내기 위해 목적지를 찾을 때 **주소**를 사용한다.
- 네트워크 세계에선 **IP 주소**라는 **유일한 구분자**가 있다.
    - IP 주소 : Internet Protocol Address
    - 유일한 구분자 : Unique Identifire
- IP중 IPv4 형식의 주소인 경우엔 8bit 숫자 4개가 모여 총 32bit로 구성되어있다.
    - 192.168.0.10 → 2진수로 8비트씩 4묶음
    - 10진수 IP주소를 2진수로 전환하거나, 2진수 IP 주소를 10진수로 전환할 수 있어야 함.
- 하나의 네트워크에 연결할 수 있는 최대 컴퓨터의 개수는 255 ^ 23 = 약 43억개

### 중간 장치

- 컴퓨터들간의 연결용 중간 장치 : 스위치
- 스위치들간의 연결용 중간 장치 : 라우터
    - 라우터끼리 연결되어 있는 네트워크는 서로 독립적
- PC에 IP를 부여하는 프로토콜은 라우터에 위치한 DHCP
    - DHCP : Dynamic Host Configuration Protocol
    - 어떤 라우터가 담당하고 있는 네트워크에서 사용 가능 주소가 192.168.10.0 ~ 192.168.10.255라면 이론상 존재 가능한 PC는 256대

### 통신 대상 탐색

- 동일한 서브넷에서 PC1이 PC2를 찾아가는 방법
    - 192.168.10.1 → 192.168.10.2 가는 것
    - 스위치의 서브넷1 범위가 192.168.10.0 ~ 192.168.10.127
    - 즉, 같은 서브넷 범위에 있으므로 스위치에게 문의하자마자 바로 연결
- 서로 다른 서브넷에서 PC1이 PC2를 찾아가는 방법
    - 192.168.10.1 → 192.168.10.128 가는 것
    - 스위치의 서브넷1 범위가 192.168.10.0 ~ 192.168.10.127
    - 즉 스위치의 서브넷 범위에 없으므로 상위에 연결된 라우터의 범위를 확인
    - 라우터가 담당하는 서브넷1, 2, 3… 들 중 서브넷2의 범위가 192.168.10.128 ~ 192.168.10.255
    - 라우터가 서브넷 2로 전달 후 거기서 PC2를 연결
- 다른 네트워크에 있는 서버를 찾아가는 방법
    - 스위치 문의 → 라우터에 문의 → 상위 라우터에 문의
    - 이런 방식으로 인터넷에 연결된 여러 라우터들을 거쳐가 연결
- 그러나 IP의 범위는 최대 약 43억개이지만, 실제로 사용되는 장치의 개수는 이보다 훨씬 많음
- 대체 어떻게 해야 인터넷에 연결할 수 있나?

- IP 주소는 우선 **절대로 동일하면 안되며, 통신이 불가능함**
- 예를 들어 192.168.0.1 PC가 다른 인트라넷에 존재하는 192.168.0.5에 가고 싶어도, 스위치에게 문의하자마자 그냥 지금 네트워크에 있는 192.168.0.5로 보내줘버림
- 여기서 나온 아이디어가 네트워크 내부의 IP와 인터넷의 IP 범위를 서로 다르게 설정
    - **공인 IP** (퍼블릭 IP) **와 사설 IP** (프라이빗 IP)
        - 사설 IP 범위 → 다른 네트워크와는 **겹쳐도 괜찮음**
            - A 클래스 : 10.0.0.0 ~ 10.255.255.255
            - B 클래스 : 172.16.0.0 ~ 172.31.255.255
            - C 클래스 : 192.168.0.0 ~ 192.168.255.255
        - 공인 IP 범위 → **절대로 겹치면 안 됨**
            - 그 외에 나머지 모든 대역
- 전 세계 대륙에 있는 장치들끼리 IPv4 주소 하나만으로 통신하기엔 동일 IP 대역끼리 통신도 안되고, 다른 IP 대역이어도 다른 IP 대역을 쓰는 장치가 너무 많아 통신이 불가능
- 따라서 한 서버에 **공인 IP** (100.0.0.1) 을 할당하고, 해당 서버의 여러 장치들에 **사설 IP** (192.168.0.1) 가 여러 개 존재하는 방식
- 내부 네트워크에 있는 서버와 통신할 땐 사설 IP 주소 사용, 인터넷을 통해 연결된 서버와 통신할 땐 공인 IP 주소 사용
- **라우팅 테이블** : 라우터에서 경로를 찾기 위해 제공하는 규칙 정보가 테이블(구조체) 형태로 제공
    - 라우터마다 라우팅 테이블이 달려있으며, 사용 가능한 서브넷 범위는 local이며 나머지는 인터넷으로 가라는 정보가 담겨있음
- **NAT**(Network Address Translation) : 인터넷과 연결할 때만 대표 공인 IP 주소를 사용하는 방법
    - 인터넷 바깥으로 나갈 때만 사설 IP가 아닌 공인 IP를 사용하는 것
    - 공인 IP로 원하는 서버를 찾았다면 그 안에서 원하는 목적지를 찾을 땐 **포트**를 사용함
- 스마트폰의 IP는 통신사가 뿌려준 사설 IP를 사용하고 있다가, 인터넷에 연결할 때만 해당 통신사의 NAT IP를 사용하는 방식으로 엄청 많은 스마트폰의 개수가 감당 가능하게 된 것
- EC2 인스턴스에 우리가 IP도 직접 구축하여 네트워크를 만들어볼 것
- 이 AWS에 네트워크를 구축하는 것이 **VPC**(Virtual Private Cloud)

## VPC

- CIDR을 이해하고, IP 범위를 계산할 수 있으며, VPC를 통해 네트워크 환경 구축하고 EC2 인스턴스 연결하기

### CIDR

- 우선 IP 주소의 범위를 좀 더 간단하게 표현하자 : **CIDR**
    - 192.168.0.0 ~ 192.168.0.255 범위를 간단하게 표현하기
    - → 192.168.0.0**/24**
    - 여기서 24는 전체 32bit중 앞 24bit는 고정하고 나머지 8bit를 주소 범위에 사용한다는 의미
        - 즉, 192.168.0 은 고정, 뒤의 .0은 주소 범위로 사용
        - 11000000 10101000 00000000 → 24비트는 고정
        - 00000000 ~ 11111111 → 8비트는 주소 범위로 사용
    - 이 방식이 싸이더(CIDR, Classless Inter-Domain Roution) 이라고 하며, 이것은 클래스의 범위와는 관계 없이 주소의 범위를 지정하는 방식이다.
- /24 라면, IPv4가 32비트이므로 32-24 = 8이므로 2^8 = 256개의 IP를 사용 가능하다고 표기하는 것
    - 192.168.0.0/28 이라면 2^4 이므로 16개의 IP 사용 가능
    - 이 땐 192.168.0.0 ~ 192.168.0.15 까지가 범위가 된다.
    - 232.12.0.0/16 이라면 2^16 이므로 65,536 개의 IP 사용 가능
    - 이 땐 232.12.0.0 ~ 232.12.255.255 까지가 범위가 된다.

### VPC (격리형 클라우드 리소스)

- AWS에서 독립적인 하나의 내부 네트워크를 구성하는 방법
- 기본적으로 계정을 생성하면 기본 VPC가 생성된 상태로 제공되지만, 별도의 네트워크를 구성하려면 사용자 지정 VPC가 필요하다.
- AWS에 VPC 검색해서 Name이 ‘-’로 있는 것이 기본 VPC
- VPC에서 IP CIDR 구성 시 IP network prefix는 /16 ~ /28까지가 범위
- VPC 생성 실습에서 CIDR를 192.168.0.0/24로 설정하여 256개의 IP가 할당이 가능해짐

- 네트워크 주소 범위(서브넷)를 분할해 줄 수 있음
- 192.168.0.0/24 → 192.168.0.0/25 로 범위를 줄일 수 있음
    - 이럴 경우 0~255까지 되던 것이 0~127과 128~255로 작게 두 개가 분할이 됨
    - 즉, 192.168.0.**0**/25와 192.168.0.**128**/25 두 개가 된 것
- 이렇게 주소 범위를 더 작은 범위 서브넷으로 분할하는 것을 **서브네팅**(Subnetting)이라고 함

- 퀴즈
    - 196.0.10.0/24 를 2개의 서브넷으로 분할한 CIDR 블록 표기
        - 196.0.10.0/25
        - 196.0.10.128/25
    - 196.0.10.0/23 을 3개의 서브넷으로 분할한 CIDR 블록 표기
        - 196.0.10.0/24
        - 196.0.10.0/25
        - 196.0.10.128/25

# ■ 7주차 (4월 19일)

- 196.0.10.0/23 을 3개의 서브넷으로 분할하려면?
    - 위는 2^9비트이므로 512비트를 3개로 쪼개야 함
    - 쪼개는 단위는 반드시 2의 제곱수여야 하므로, 256 / 128 / 128 로 쪼갤 수 있음
    - 10 → 00001010인데, 9비트까지가 주소 범위이므로 마지막 0은 주소 범위로 변동 가능
    - 196.0.10.0/24
    - 196.0.11.0/25
    - 196.0.11.128/25
    - CIDR 문제는 반드시 2진수로 변환하여 해결 후 다시 10진수로 변환하는게 편함
- 각 서브넷 간의 IP는 절대 겹쳐서는 안되며, 서브넷의 크기는 서로 다를 수 있음
- 여러 서브넷끼리는 라우터가 중간장치가 되어줌

## 서브넷 생성하기

- AWS 서비스 중 VPC 서비스에서 새로 만들어낸 VPC를 여러 서브넷으로 분할할 수 있음
- 서브넷 탭으로 이동한 뒤 서브넷 생성 - 원하는 VPC 선택 - 서브넷 블록 직접 입력 후 분할 가능
- 생성이 됐다면, 내 AWS 계정 내에 내가 만든 VPC가 있고, 그 VPC 내부에 두 개의 서브넷 존이 생김
- 그러나 이것은 오로지 인트라넷으로만 쓸 수 있는 폐쇄된 공간이며, 인터넷에 연결하기 위해선 인터넷 게이트웨이를 생성해주어야 함

## 인터넷 게이트웨이 생성하기

- VPC별로 인터넷 게이트웨이가 존재해야 함
- 생성은 단순히 이름만 작성하면 만들어짐
- 이후 작업 - VPC 연결에서 원하는 VPC를 선택하면 해당 VPC가 인터넷으로 나갈 수 있는 길이 열림
- 그러나 또 이렇게 했다고 바로 인터넷을 쓸 수 있는 것이 아니며, 최종 목적지로 찾아가기 위해 중간장치에게 물어보는 과정을 거쳐야 하는데, 거기에 필요한 리소스가 ‘라우팅 테이블’ 이다.

## 라우팅 테이블 생성하기

- 일단 기본적으로 라우팅 테이블이 생성되어있음
- 라우팅 테이블 탭으로 들어간 뒤에 내가 만든 VPC를 선택하고 나면 해당 라우팅을 편집할 수 있게 되며, 인터넷을 쓰기 위한 규칙을 직접 추가해주어야 함
- 라우팅 편집 - 라우팅 추가 - 우리가 지정하고 싶은 IP의 범위 입력
    - 여기서 우리가 넣을 값은 0.0.0.0/0 → 존재가능한 모든 IP 범위 (43억개)
- 대상엔 여러가지 종류가 있으나 ‘인터넷 게이트웨이’ 선택을 하면 됨. 그럼 자동으로 뒤의 키가 생성됨
- 이후 변경 사항 저장을 누르면 라우팅 테이블을 수정하게 되고 인터넷을 이용 가능하게 됨

- 그러나, 이럴 경우 기본으로 있던 192.168.0.0/24 와 새로 만든 규칙인 0.0.0.0/24 가 내부 집합으로 겹쳐버리게 됨
- 그럼 이럴 경우 192.168.0.10을 찾으면 어느 폭에 있는 라우팅 테이블로 가게 될까?
- 이건 ‘가장 폭이 작은 범위’ 로 자동으로 가도록 규칙 약속이 되어있음
- 즉 192.168.0.0/24를 먼저 계산하고, 여기에 없으면 0.0.0.0/0 에서 찾게 된다.

1. 192.168.0.0/24 → 이 대역의 IP로 전달하는 패킷은 내부에 대상이 있으니 내부에서 찾으시오
2. 0.0.0.0/0 → 그 외 나머지 모든 IP 대역으로 전달하는 패킷은 모두 인터넷 게이트웨이로 전달하시오

- 그래서 우리는 인터넷으로 나갈 수 있는 VPC를 지정한 뒤에, 해당 사용 가능한 IP범위 주소 내에 EC2 인스턴스를 생성하여 SSH로 접속이 가능하게 된 것.

## 탄력적 네트워크 인터페이스

- NIC(Network Interface Card) : 컴퓨터가 네트워크 연결을 위해 따로 장착해야 하는 네트워크 인터페이스 카드. 그러나 요즘엔 메인보드에 다 내장되어있음.
- NIC에 IP를 할당해주고, 이를 통해 컴퓨터 간에 실제로 통신이 이루어짐.
- NIC를 여러 개 설치하면, 여러 개의 IP를 가질 수 있어 하나의 기기에서 여러 네트워크에 접속 가능

- AWS에선 NIC 역할을 하는 리소스인 ENI(Elastic Networtk Interface)가 존재함
- EC2 인스턴스 생성 시 기본으로 ENI가 생성되어 연결하며, 이는 절대로 해제가 불가능하다.
- 조금 특이한 점이라면 ENI 하나에 공인 IP (Public IP) 와 사설 IP (Private IP) 가 쌍으로 하나씩 연결된다.

- EC2 인스턴스 생성 후 네트워크 설정에 가보면 퍼블릭 IP 자동 할당이 활성화되어 있는데, 이 것을 비활성화해주면 퍼블릭 IP가 자동 할당되지 않음.
- 비활성화 하면 퍼블릭 IPv4는 아예 할당되지 않고, 프라이빗 IPv4는 DHCP라는 시스템이 알아서 서브넷 주소 내부의 IP중 하나로 할당해준다.

## DHCP (Dynamic Host Configuration Protocol)

- 네트워크에 연결된 장치에 IP를 자동으로 부여하는 서비스
- 퍼블릭 IP는 인스턴스를 중지하고 시작할 때마다 계속 바뀐다. (유동 IP)
    - 재부팅은 VM이 꺼지지 않아서 바뀌지 않고, 중지 했다가 켜야만 바뀜
- 프라이빗 IP는 바뀌지 않고 고정되어있다.

## 탄력적 IP (Elastic IP)

- 현재 인스턴스를 퍼블릭 IP가 할당되지 않은 상태로 생성했기 때문에, 인터넷 연결이 절대 되지 않음
- 이제 컴퓨터를 껐다 켜도 퍼블릭 IP가 영구적으로 바뀌지 않는 (고정 IP) 엘라스틱 IP를 부여할 것임
- 탄력적 IP 탭에 가서 IP 할당 클릭하면 간단하게 할당됨
- 퍼블릭 IPv4 주소 풀을 하나 고를 수 있는데, 이건 해당 나라의 공인 IP 범위가 완전히 정해져있어서 그 내부에서만 설정되는 것이다. 공인 IP는 제멋대로 설정할 수 없음
    - 제멋대로 설정했다간 인터넷 국제 기구에서 정한 IP가 아니므로 인터넷에 연결할 수 없게 됨
- 할당하면 나를 특정할 수 있는 유일한 공인 IP가 하나 생성됨
- 이제 작업 - 탄력적 IP 주소 연결을 누르면 인스턴스 혹은 네트워크 인터페이스(ENI) 둘 중 하나에 연결이 가능해진다. 일단 지금은 인스턴스에 할당할 것
- 이렇게 되어야 공인 IP를 할당받아서 드디어 인터넷에 연결이 가능해진 것.
- 이걸로 할당받은 퍼블릭 IPv4 주소로 PuTTy 연결도 당연히 가능하며, 인스턴스를 중지 후 시작해도 공인 IP가 바뀌지 않은 것을 확인할 수 있다.

- 가격
    - 실행 중인 인스턴스에 연결된 1개의 EIP에 대해서는 무료 제공
    - 그러나 각 추가 IP 주소에 대해선 시간당 0.005USD가 과금된다.
    - 이 공인 IP는 완전히 유일한 것이라서, 남이 쓸 수 있는 것을 내가 사용하는 것이므로 점유에 대한 비용을 지불해야 하는 것.
    - 또한 연결되지 않은 탄력적 IP 주소에 대해 시간당 0.005USD → 안 쓸거면 생성하지 마라.
    - 거기에 IP를 인스턴스에 재매핑 하는 것만으로도 과금이 들어감.
        - 대용량 서버 막 확장하고 축소할 때 IP 마구 재연결하는 것을 방지

## AWS 글로벌 인프라

- AWS는 글로벌 서비스고, 국가적으로 거리가 멀어지면 멀어질 수록 굉장히 속도가 느려진다.
- 이것을 해결한 방법이 그냥 고객들이 있는 국가에 데이터센터를 지어버리는 것.
- 특정 지역에 위치한 데이터 센터들의 집합을 ‘리전’(Regions) 라고 한다.
- 현재 전세계 31개의 리전이 존재
    - 좀 더 세부적인 단위로 쪼개면 99개의 가용 영역
    - 좀좀 더 세부적인 단위로 쪼개면 400개 이상의 엣지 로케이션
- 하나의 국가에 필요한 경우 여러 개의 리전이 존재할 수 있음.
- 한국에도 한 개의 리전이 존재한다.

- 엣지 로케이션
    - 리전이 없는 국가는 너무 느리므로, 그 중간중간 공백에 매우 소규모의 데이터 센터인 엣지 로케이션이 설계되어 있음.
    - 넷플릭스에서 영상 하나를 구하면 모든 엣지 로케이션에 전부 일괄적으로 업로드 됨
    - 그래서 리전이 없는 곳이어도 주변의 엣지 로케이션에서 영상을 구해와 이 속도차를 커버함

- 우리 나라엔 4개의 데이터 센터가 있다. 이 4개의 데이터 센터를 서울 리전이라고 함
- 우리가 AWS Academy 에서 쓸 수 있는 것은 US East의 버지니아 (us-east-1)
- 나중에 실제로 AWS 쓸 땐 서울 리전 쓰면 됨 (ap-northeast-2)

- 리전에 따라 주소가 바뀌므로, 이런 리전의 영향을 받는 서비스는 리전 기반 서비스라고 함
- 특정 리전에서 할당 받은 서비스는 해당 리전 내의 데이터 센터에서만 구동 (EC2 역시 그럼)
    - 미국에서 서비스하고 싶다면 미국의 리전에 EC2 인스턴스를 띄워야 함
- 따라서 의도치 않게 엉뚱한 리전에 서비스를 구축해버리는 실수에 주의

- 반대로 리전과 반대 개념인, 어디에 설정해도 괜찮은 글로벌 기반 서비스가 존재함
- IAM 역시 글로벌 기반 서비스인데, 이 서비스는 접속 시 리전 영역이 글로벌로 변경되는 것을 확인 가능

## 가용 영역

- 한국은 데이터 센터가 4개 있는데, 한국의 리전은 1개이다.
- 1개 이상의 데이터 센터의 집합을 ‘가용 영역’ 이라는 이름으로 묶어놓고, 이 가용 영역을 1개 이상으로 묶어놓은 것이 AWS 리전이 된다.
- 어째서 이런 구조를 가지고 있는가? → 그 이유는 ‘고가용성’ 때문

- 고가용성 : On-Demand, 확장성, 탄력성 등을 이용해 특정 서버에 문제가 발생하더라도 다른 서버에 사용자 요청을 처리하는 것
    - On-Demand : 서버 및 장비를 원하는 때에 원하는 만큼 사용하는 것이 가능
    - 확장성, 탄력성 : 필요한 경우 추가 대여 및 반납이 가능
- 서버가 여러개가 있어야 특정 서버에 문제가 생겨도 다른 서버가 처리해줄 수 있음

- 오케이. 특정 사용자가 고가용성을 위해 한 데이터 센터에 인스턴스를 n개 만들었다고 치자.
- 그러나 그 데이터 센터가 문제가 생겨버리면 모든 인스턴스가 다운이 되어버린다.
- 따라서 애초부터 여러 곳의 데이터 센터에 인스턴스를 각각 만들어야 특정 데이터 센터에 문제가 생기더라도 정상적으로 서비스를 운영하는 것이 가능하다. → 이것이 고가용성

- DNS에 이어져있는 여러 개의 로드 밸런서가 여러 데이터 센터에 있는 인스턴스들에 연결되어있음
- 그러던 중 50만큼의 인구수를 차지하던 데센에 문제가 생기면 다른 50만큼의 인구수를 쓰던 데센에 모든 트래픽이 몰려 100만큼의 인구수가 사용하게 됨
- 이대로 가면 서버가 과부하가 오므로 해당 데센에 확장성을 통해 인스턴스를 몇 개 빌려 100만큼의 인구수를 감당
- 이후 문제가 생긴 데센이 복구가 되면 다시 50만큼의 인구수를 원래대로 돌려놓고 빌렸던 인스턴스들을 다시 반납

- 그래서 이 데센들의 묶음을 가용영역이라고 하고, 이 가용영역들을 지역별로 뭉친 것이 리전.
- 같은 가용 영역의 데이터 센터끼리는 전용선으로 연결되어있음.
- VPC에서 각 서브넷은 반드시 하나의 가용 영역에 속하게 됨
- 즉, 하나의 서브넷에 문제가 생기더라도 다른 서브넷은 정상적으로 동작하게 됨 → 고가용성
    - VPC는 하나의 리전에 매핑됨
    - 서브넷은 해당 리전의 각각 가용영역에 매핑됨