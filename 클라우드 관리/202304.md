# ■ 5주차 (4월 5일)

- touch 명령어로 빈 파일을 생성할 수 있음
    - touch ebs.txt
- echo와 redirection 명령어로 파일을 생성할 수 있음
    - echo “ebs” > instance_store.txt

- echo : 인자로 받은 문자열을 printf로 출력하는 프로그램
- redirection : 우선 일반적인 명령어, 애플리케이션, 프로그램이 아닌 리눅스의 기능임. 인자로 받은 값을 다른 프로그램의 인자로 전달하는 기능으로, > 명령어로 쓸 수 있음
- touch : 파일의 생성 시간을 변경하거나 새로운 파일을 생성하는 프로그램
    - 이미 존재하는 파일을 인자로 주었을 땐 파일의 수정 시간을 현재 시간으로 변경

- 서비스를 시작한 후 사용을 하다 보면 모든 스토리지 용량이 전부 차게 될 수 있음, 이렇게 될 경우 서비스가 중단될 수 있다
- 그럴 경우 기존 파일을 삭제할 수 있지만 기존 파일을 삭제하지 못하는 경우 디스크 볼륨을 추가할 수 있다
- AWS EC2탭의 Elastic Block Store - 볼륨 탭으로 이동
- 스토리지의 동작 원리는 논리적 볼륨 생성 - 파일 시스템 추가 - 가용 시작
- 별도로 설정할 건 없고, 용량만 우리가 정해주면 됨
- 단, 가용 영역이라는 메뉴가 있는데 이것은 ‘어떤 데이터 센터’에 있는 볼륨을 쓸 지 선택까지 해야함
    - 이 경우 EC2 인스턴스의 데이터 센터와 맞는 **가용 영역**에 맞게 추가해주어야 함
- 볼륨 생성 후 일정 시간이 지나면 사용 가능 상태가 되며, 작업 - 볼륨 연결로 볼륨 추가가 가능
- 인스턴스에 연결했으면 그 상태에서 바로 lsblk 사용해보면 새 블록이 할당된 걸 볼 수 있음
- 리눅스의 파일 시스템에 따라 디스크 볼륨을 특정 디렉토리에 연결해야 함
    - 파일 시스템 생성은 다음과 같은 명령어로 가능
        - sudo mkfs.ext4 /dev/xvdf
        - mkfs → make file system
        - ext4 → 가장 빈번하게 사용되는 파일 시스템들 중 하나
        - 어디다가 만들거냐? → /dev/xvdf
        - 그러나 이 명령어는 일반 사용자로는 실행이 되지 않아 sudo로 실행해야 함
    - 파일 시스템을 생성했다면 디렉토리에 연결해야 하며, mount 명령어를 사용
        - 디스크 볼륨에 생성된 파일 시스템을 디렉토리에 마운트하는 명령어
        - mkdir test
        - sudo mount /dev/xvdf test
        - logout 후 위 명령어를 실행하면 홈 사용자 디렉토리 아래에 생성된 디렉토리가 아까 만든 볼륨을 차지하는 디렉토리로 생성이 됨
- 이후 이 볼륨을 분리 후 삭제하려고 하면, 볼륨 분리가 되지 않음. 왜냐하면 mount가 된 디스크 볼륨은 뜯을 수가 없기 때문임
- 볼륨을 분리하는 명령어는 unmount
    - sudo umount /dev/xvdf
- 이후엔 AWS 볼륨 분리가 가능해짐
- 볼륨이 분리되면 다시 사용 가능 상태로 전환되며, 볼륨 삭제를 눌러 데이터 센터에 스토리지를 반납할 수 있음
- 정말 중요한건, 이 모든 과정이 **서비스 중단 없이 인스턴스가 동작중인 상태에서 가능**하다는 점이다

## 5주차 수업

- 우리의 최종 목표는 three-tier 형태로 서버를 구축해보는 것
- three-tier 형태로 AWS환경에 서버를 구축하기 위해선 PHP와 Apache를 설치할 줄 알아야 하며, 이는 모두 리눅스 명령어를 숙지해야하만 가능한 환경 구축이다.
- 하여 소프트웨어를 설치하고 관리 및 운영을 하면 로그(log)가 남으며, 해당 로그를 읽고 관리할 수 있도록 연습하여야 한다.

- 이번 수업 시간엔 인스턴스 유형을 포함한 키 페어, 고급 세부 정보를 건드려볼 것

- EC2에서 컴퓨팅 자원 배포는 다음과 같이 이루어진다.
    - SW와 OS는 AMI로 미리 설치할 수 있다
    - CPU와 Memory, Network는 인스턴스 타입에 따라 성능이 결정된다
    - Storage는 물리서버로 EBS에서 네트워크로 독립적인 연결로 이루어진다

## 인스턴스 유형 수직 확장 (Scale-up)

- 지금까지는 인스턴스 타입을 변경할 때 인스턴스를 종료하고 새로 만들었으나, 중지 상태에서 기존에 사용중인 EC2 인스턴스의 타입을 더 높은 성능으로 갈아끼울 수 있다
- 이를 **수직 확장(Scale-up)**이라고 부른다.
- 인스턴스 개수를 늘려 가용성을 늘리는 것은 **수평 확장(Scale-out)**이라고 부른다.

- 원래 지금까지는 원격 연결을 하려면 키페어 방식으로 ppk 파일을 다운받아서 연결했으나, 이 키페어 파일이 유출되면 큰일나는 방식이었다
- 그러나 인스턴스 항목에서 원하는 인스턴스를 선택한 후 ‘연결’을 누르면 키페어 없이 브라우저에서 바로 CUI 환경을 가용시킬 수 있다

- 인스턴스를 수직 확장하고 싶다면, 우선 인스턴스를 중지해야 함
    - 즉, 만약 서비스가 이미 진행중인데 수직 확장을 하려면 인스턴스를 중지해야 하므로 사용자들에게 피해가 가는 것은 어쩔 수 없음
    - 이것은 2개 이상의 인스턴스를 만들어 ‘다중화’를 해야하고, 한 인스턴스가 종료되었을 때 사용자의 입력 처리를 다른 인스턴스에 받는 것임. 이를 ‘롤링 업데이트’라고 부름
    - 우선 지금은 1대만 가지고 실습
- 중지됨 상태가 되면 인스턴스 선택 후 작업 - 인스턴스 설정 - 인스턴스 유형 변경 선택
- 여기서 원하는 인스턴스를 선택하고 확인하면 인스턴스 유형을 변경할 수 있게 됨

## 키 페어 생성 및 사용

- 네트워크 및 보안 메뉴에서 키 페어 탭에 들어가야 함
- 들어가면 vockey 하나가 기본적으로 존재하며, 키 페어는 사실 암호화를 위한 무작위 긴 문자열
- 키 페어 생성 시 키 페어의 이름과 여러가지 설정을 할 수 있음
    - 키 페어 유형 : 암호화를 하는 방법 선택
    - 암호화 알고리즘들 중 가장 보편적인 알고리즘 하나가 RSA 알고리즘
    - 서버에는 퍼블릭 키가 있고, 우리는 프라이빗 키를 가지고 있음
        - pem파일은 리눅스 환경에서 OpenSSH와 함께 사용
        - ppk파일은 윈도우 환경에서 Putty와 함께 사용
        - 내용 자체는 똑같고 파일의 포맷이 달라지는 것, 파일을 파싱할 때 어떤 형식인지 알아야 각 프로그램에 맞게 해석할 수 있는 것
- 이렇게 키페어를 생성했다면 인스턴스 생성할 때 원하는 키페어를 선택할 수 있음
- 단, 이 키 페어 파일이 유출되어 해킹을 당하면 우리의 관리가 부실했던 것이므로 우리의 책임

## 사용자 데이터

- 사용자 데이터는 윈도우로 따지면 ‘시작 프로그램’
- 인스턴스 시작 시 자동으로 실행되는 스크립트를 지정하는 것이며, 코딩으로 직접 환경을 지정 가능
- 스크립트(Bash, PowerShell)를 사용하여 인스턴스의 런타임 환경을 지정 가능
    - 단, 기본적으로는 인스턴스가 최초로 시작될 때 한 번만 스크립트가 실행됨
- AMI를 만들 필요 없이 사용자 데이터를 실행해 초기 환경을 구성하는 것이 가능
    - 사용자 데이터에 yum 명령어와 함께 무언가를 설치하는 것이 가능하다는 것
    - yum 명령어는 프로그램을 설치할 수 있는 패키지 관리자 명령어
- 인스턴스를 생성할 때 다른 부분은 그대로 두고, 고급 세부 정보 칸의 사용자 데이터에 원하는 스크립트를 입력하는 것
- 사용자 데이터에서 명령어 인자로 경로를 지정할 땐, 반드시 절대경로로 명시를 해주어야 함.
    - 사용자 데이터 스크립트는 루트 사용자 권한으로 실행되기 때문
- 리다이렉션엔 여러가지 방법이 존재
    - ‘>>’ : 특정 명령의 실행 결과를 파일에 쓰는데, 기존 내용의 다음 줄에 쓰게 됨
    - ‘>’ : 특정 명령의 실행 결과를 파일에 아예 덮어씌워버림 (overwrite)
- **예상 시험 문제 (리눅스 명령어)**
    - 다음 명령어의 실행 결과를 쓰시오
    - 다음 실행 결과를 수행할 명령어가 무엇인가

## 파이썬으로 심플 웹서버 실행

- 인스턴스 생성 시 네트워크 설정에서 ‘인터넷에서 HTTP 트래픽 허용’ 체크
- 아래와 같은 명령어 실행

```livescript
sudo mkdir -p /var/www/html
cd /var/www/html
sudo python3 -m http.server 80
```

- 위 경로는 html 웹 서버를 열 때 가장 보편적으로 사용되는 디렉토리 경로
- HTTP 서버는 기본적으로 80번 포트를 사용

## 리소스 관리

- 리소스(Resource)
    - 사용자가 생성하거나 AWS 서비스를 통해 자동으로 생성되는 모든 가상 자원
    - 예를 들어 EC2 인스턴스, EBS, 보안 그룹 (방화벽), 키 페어 등등…

- ARN(Amazon Resource Name)
    - 리소스를 구분하기 위한 유일한 식별자 (Identify)
    - 리소스를 생성하는 시점에 이미 결정이 됨
    - ARN의 구성, 형식은 아래와 같음
        - 서비스명
        - 리전(Region) : AWS의 데이터 센터가 위치한 지역
        - AWS 계정 ID
        - 리소스 유형 (Type)
        - 리소스 ID
        - 선택적인 추가 구성 요소
        
- 리소스의 리전(Region)은 데이터 센터가 존재하는 물리적 위치인데, 아카데미의 경우엔 버지니아 북부로 설정되어있으며 대한민국 서울은 아카데미 ID로는 권한이 없음
- ARN 정보만으로는 그 리소스가 어떤 역할이고 무슨 기능을 수행하는지 구별하기엔 어려움
- 그러나 태그(Tag)를 보면 리소스가 어떤 역할을 수행하는지 확인할 수 있음
    - 키와 값으로 구성되어 있음 (키는 필수, 값은 선택)
    - 태깅은 EC2 인스턴스에 의미와 정보를 부여
    - 태그가 없으면 어떤 사용자가 어떤 목적으로 인스턴스를 사용하는지 확인이 어려움
    - 마치 주석같은 존재
- 태깅의 장점
    - 필터링 : 원하는 태그의 리소스들만 선택하여 일괄적인 작업 수행
    - 자동화
    - 비용 할당
    - 액세스 제어
- 보안 그룹 탭에서 원하는 보안 그룹의 태그 관리 - 태그 설정으로 해당 보안 그룹이 어떤 역할이고 어떤 태그가 붙어있는지 확인할 수 있음
- 그러나 또 막상 인스턴스 생성할 때 보안 그룹 선택할 땐 태그 네임이 뜨지 않아 아쉽긴 함
    - 그래서 자동생성 보안 그룹 말고 직접 생성할 때 보안 그룹 이름을 태그의 Name과 동일하게 작명하여 구별을 쉽게 함

- 이후 Resource Groups 서비스에 들어가 새로운 그룹을 생성하면, 태그 키와 태그 값에 우리가 입력해두었던 태그가 자동으로 뜸
- 해당 태그를 설정하고 리소스 그룹을 만들면 해당 그룹에 들어가있는 모든 리소스를 일괄적으로 관리할 수 있음. 이걸 목적으로 태깅을 하는 것
- EC2는 수많은 서비스들 중 하나일 뿐. AWS계정 하나에 제공하는 200개 이상의 수많은 서비스 사용 가능
- 이 서비스들은 대부분 리눅스와 매우 유사하며, IAM(Identity and Access Management) 서비스를 통해 사용자 관리 가능
    - IAM을 통해 다양한 사용자를 만들어 ID와 PW를 통해 로그인 시킬 수 있으며, 사용자에 따라 서비스 사용에 대한 권한을 다르게 설정할 수 있음
    - 우리는 ec2-user라는 IAM 사용자로서 활동중임
- AWS 계정 이름을 보면 abc@123-456… 형식으로 명명되어있음
    - 골뱅이 앞의 내용은 유저의 ID
    - 골뱅이 뒤의 내용은 AWS 계정 아이디
- 루트 어카운트는 정말 필요할 때만 사용하고, 대부분은 ec2-user같은 IAM 사용자로 로그인하여 사용
- IAM사용자에 따라 AWS 서비스를 다루기 위한 권한이 다르다.
    - 예를 들어 어떤 사용자는 EC2 인스턴스 실행, EC2 인스턴스 중지 작업은 가능하지만 EC2 인스턴스 종료는 할 수 없게 권한을 설정할 수 있음
    - 우리 아카데미 환경에선 AWS academy에서 주어진 권한만 사용 가능함. 우리가 실제로 AWS 계정을 만들어 쓰게 되면 사용자에 대한 권한을 직접 설정할 수 있음
    
- IAM 역할 (Role)
    - 서비스에서 생성한 리소스가 직접 권한을 가지고 액션을 취할 수도 있다.
    - 즉, 사용자가 보유중인 권한으로 사용자가 원하는 액션을 취하는 것이 아닌 EC2 인스턴스에게 무언가 권한을 주고 그 리소스가 액션을 취하게 한 뒤 결과물을 사용자가 볼 수도 있다
    - 이런 리소스 자체에 권한이 주어진 것을 IAM 역할이라고 함
    - 즉, 리소스에게 마치 사람처럼 권한을 주고 원하는 액션을 취하게 할 수 있는 것
    - 예약을 걸어두면 원하는 동작을 자동으로 실행할 수 있다
        - 즉, 사람이 직접 로그인하지 않아도 리소스들한테 권한 주고 다 시켜놓으면 약속된 작업들을 자동적으로 수행할 수 있게 함

# ■ 6주차 (4월 12일)

- 우리는 IAM 사용자로서 로그인하여 EC2 인스턴스를 다루고 있고, 이와 관련된 어떠한 행동을 해도 반드시 이 사용자가 권한을 가지고 있는지 한번 체크를 한다.
- 그러나 AWS가 생성한 리소스에도 권한을 부여할 수 있고, 역할을 수행하게 할 수 있으며 이 것을 IAM 역할이라고 한다.
- aws ec2 describe-instances 명령어로 EC2 인스턴스 명령 조회를 할 수 있다.
    - 그러나 당장 이 명령어는 우리가 권한이 없어 실행할 수 없다.
- IAM 역할을 할당시켜주기 위해선 인스턴스 선택 후 작업 - IAM 역할 수정을 선택하면 된다.
    - 그러나 우선 러너 랩 환경에선 쓸 수 있는 IAM 역할은 몇 개가 미리 할당되어있다. 우리가 후에 직접 계정을 생성해 쓰면 여러가지 권한이 정말 많음.
- 역할을 할당해주고 다시 위의 명령어를 쓰면 명령어가 써지는 것을 확인할 수 있다.
- 사용자 데이터로 위 명령어를 원하는 파일에 써두는 것을 미리 작성할 수 있으며, IAM 역할은 인스턴스를 생성할 때 IAM instance profile에서 미리 체크해두고 생성할 수 있다.

## 네트워크 기본 개념

- three-tier 아키텍처로 AWS 환경을 구축하려면 클라이언트와 서버를 연결하는 부분을 우리가 만들어야 함
- **네트워크** : 컴퓨터와 컴퓨터 사이를 연결하여 서로 통신할 수 있게 되는 것
- 네트워크를 구축하는 방법
    - 물리적으로 두 PC간의 케이블을 연결한다. (LAN 케이블)
        - 그러나 이 방법은 통신해야하는 컴퓨터를 늘릴 때마다 물리적인 연결을 계속해서 늘려줘야 해서 매우 복잡해진다. 이랬다간 컴퓨터 10개만 되어도 선이 너무 많아진다.
        - 그러나 컴퓨터 사이를 연결하는 중간 장치를 두게 되면 각 컴퓨터당 하나의 연결만 해도 되긴 한다.
    - 이제 중간 장치로 연결한 여러 PC들의 집합 두 개를 연결하기 위해선, **중간 장치들끼리**를 서로 연결해주어야 한다.
        - 그럼 여기서 또 네트워크가 더 증가하게 되면 **중간 장치들을 위한 중간 장치**를 놓게 된다.
    - 그럼 또 이 중간 장치들을 위한 중간 장치를 연결하는 중간 장치를…
    - 아무튼 이런 형식으로 네트워크가 구축된다.
    - 이렇게 건너고 건너고 건너가서 내 PC와 AWS의 EC2 인스턴스와 연결하게 된다.
- 인터넷 : (inter : ~사이에) 작은 네트워크들을 서로 간에 연결하여 거대한 전 세계 규모의 네트워크를 구성하는 것
- 인트라넷 : (intra : ~내부에) 특정 집단에서만 사용하는 독립적인 내부 네트워크. 허가 받은 사용자만 접근 가능하며, 인트라넷은 인터넷과 연결되어있을 수도 있으나, 연결되어있지 않을 수도 있음

- 그럼 여기서, 목적지 컴퓨터로 가기 위해선 대체 어디에 있는지 어떻게 알며, 어떻게 가야하나?
- 우리 현실 세계에선 택배를 보내기 위해 목적지를 찾을 때 **주소**를 사용한다.
- 네트워크 세계에선 **IP 주소**라는 **유일한 구분자**가 있다.
    - IP 주소 : Internet Protocol Address
    - 유일한 구분자 : Unique Identifire
- IP중 IPv4 형식의 주소인 경우엔 8bit 숫자 4개가 모여 총 32bit로 구성되어있다.
    - 192.168.0.10 → 2진수로 8비트씩 4묶음
    - 10진수 IP주소를 2진수로 전환하거나, 2진수 IP 주소를 10진수로 전환할 수 있어야 함.
- 하나의 네트워크에 연결할 수 있는 최대 컴퓨터의 개수는 255 ^ 23 = 약 43억개

### 중간 장치

- 컴퓨터들간의 연결용 중간 장치 : 스위치
- 스위치들간의 연결용 중간 장치 : 라우터
    - 라우터끼리 연결되어 있는 네트워크는 서로 독립적
- PC에 IP를 부여하는 프로토콜은 라우터에 위치한 DHCP
    - DHCP : Dynamic Host Configuration Protocol
    - 어떤 라우터가 담당하고 있는 네트워크에서 사용 가능 주소가 192.168.10.0 ~ 192.168.10.255라면 이론상 존재 가능한 PC는 256대

### 통신 대상 탐색

- 동일한 서브넷에서 PC1이 PC2를 찾아가는 방법
    - 192.168.10.1 → 192.168.10.2 가는 것
    - 스위치의 서브넷1 범위가 192.168.10.0 ~ 192.168.10.127
    - 즉, 같은 서브넷 범위에 있으므로 스위치에게 문의하자마자 바로 연결
- 서로 다른 서브넷에서 PC1이 PC2를 찾아가는 방법
    - 192.168.10.1 → 192.168.10.128 가는 것
    - 스위치의 서브넷1 범위가 192.168.10.0 ~ 192.168.10.127
    - 즉 스위치의 서브넷 범위에 없으므로 상위에 연결된 라우터의 범위를 확인
    - 라우터가 담당하는 서브넷1, 2, 3… 들 중 서브넷2의 범위가 192.168.10.128 ~ 192.168.10.255
    - 라우터가 서브넷 2로 전달 후 거기서 PC2를 연결
- 다른 네트워크에 있는 서버를 찾아가는 방법
    - 스위치 문의 → 라우터에 문의 → 상위 라우터에 문의
    - 이런 방식으로 인터넷에 연결된 여러 라우터들을 거쳐가 연결
- 그러나 IP의 범위는 최대 약 43억개이지만, 실제로 사용되는 장치의 개수는 이보다 훨씬 많음
- 대체 어떻게 해야 인터넷에 연결할 수 있나?

- IP 주소는 우선 **절대로 동일하면 안되며, 통신이 불가능함**
- 예를 들어 192.168.0.1 PC가 다른 인트라넷에 존재하는 192.168.0.5에 가고 싶어도, 스위치에게 문의하자마자 그냥 지금 네트워크에 있는 192.168.0.5로 보내줘버림
- 여기서 나온 아이디어가 네트워크 내부의 IP와 인터넷의 IP 범위를 서로 다르게 설정
    - **공인 IP** (퍼블릭 IP) **와 사설 IP** (프라이빗 IP)
        - 사설 IP 범위 → 다른 네트워크와는 **겹쳐도 괜찮음**
            - A 클래스 : 10.0.0.0 ~ 10.255.255.255
            - B 클래스 : 172.16.0.0 ~ 172.31.255.255
            - C 클래스 : 192.168.0.0 ~ 192.168.255.255
        - 공인 IP 범위 → **절대로 겹치면 안 됨**
            - 그 외에 나머지 모든 대역
- 전 세계 대륙에 있는 장치들끼리 IPv4 주소 하나만으로 통신하기엔 동일 IP 대역끼리 통신도 안되고, 다른 IP 대역이어도 다른 IP 대역을 쓰는 장치가 너무 많아 통신이 불가능
- 따라서 한 서버에 **공인 IP** (100.0.0.1) 을 할당하고, 해당 서버의 여러 장치들에 **사설 IP** (192.168.0.1) 가 여러 개 존재하는 방식
- 내부 네트워크에 있는 서버와 통신할 땐 사설 IP 주소 사용, 인터넷을 통해 연결된 서버와 통신할 땐 공인 IP 주소 사용
- **라우팅 테이블** : 라우터에서 경로를 찾기 위해 제공하는 규칙 정보가 테이블(구조체) 형태로 제공
    - 라우터마다 라우팅 테이블이 달려있으며, 사용 가능한 서브넷 범위는 local이며 나머지는 인터넷으로 가라는 정보가 담겨있음
- **NAT**(Network Address Translation) : 인터넷과 연결할 때만 대표 공인 IP 주소를 사용하는 방법
    - 인터넷 바깥으로 나갈 때만 사설 IP가 아닌 공인 IP를 사용하는 것
    - 공인 IP로 원하는 서버를 찾았다면 그 안에서 원하는 목적지를 찾을 땐 **포트**를 사용함
- 스마트폰의 IP는 통신사가 뿌려준 사설 IP를 사용하고 있다가, 인터넷에 연결할 때만 해당 통신사의 NAT IP를 사용하는 방식으로 엄청 많은 스마트폰의 개수가 감당 가능하게 된 것
- EC2 인스턴스에 우리가 IP도 직접 구축하여 네트워크를 만들어볼 것
- 이 AWS에 네트워크를 구축하는 것이 **VPC**(Virtual Private Cloud)

## VPC

- CIDR을 이해하고, IP 범위를 계산할 수 있으며, VPC를 통해 네트워크 환경 구축하고 EC2 인스턴스 연결하기

### CIDR

- 우선 IP 주소의 범위를 좀 더 간단하게 표현하자 : **CIDR**
    - 192.168.0.0 ~ 192.168.0.255 범위를 간단하게 표현하기
    - → 192.168.0.0**/24**
    - 여기서 24는 전체 32bit중 앞 24bit는 고정하고 나머지 8bit를 주소 범위에 사용한다는 의미
        - 즉, 192.168.0 은 고정, 뒤의 .0은 주소 범위로 사용
        - 11000000 10101000 00000000 → 24비트는 고정
        - 00000000 ~ 11111111 → 8비트는 주소 범위로 사용
    - 이 방식이 싸이더(CIDR, Classless Inter-Domain Roution) 이라고 하며, 이것은 클래스의 범위와는 관계 없이 주소의 범위를 지정하는 방식이다.
- /24 라면, IPv4가 32비트이므로 32-24 = 8이므로 2^8 = 256개의 IP를 사용 가능하다고 표기하는 것
    - 192.168.0.0/28 이라면 2^4 이므로 16개의 IP 사용 가능
    - 이 땐 192.168.0.0 ~ 192.168.0.15 까지가 범위가 된다.
    - 232.12.0.0/16 이라면 2^16 이므로 65,536 개의 IP 사용 가능
    - 이 땐 232.12.0.0 ~ 232.12.255.255 까지가 범위가 된다.

### VPC (격리형 클라우드 리소스)

- AWS에서 독립적인 하나의 내부 네트워크를 구성하는 방법
- 기본적으로 계정을 생성하면 기본 VPC가 생성된 상태로 제공되지만, 별도의 네트워크를 구성하려면 사용자 지정 VPC가 필요하다.
- AWS에 VPC 검색해서 Name이 ‘-’로 있는 것이 기본 VPC
- VPC에서 IP CIDR 구성 시 IP network prefix는 /16 ~ /28까지가 범위
- VPC 생성 실습에서 CIDR를 192.168.0.0/24로 설정하여 256개의 IP가 할당이 가능해짐

- 네트워크 주소 범위(서브넷)를 분할해 줄 수 있음
- 192.168.0.0/24 → 192.168.0.0/25 로 범위를 줄일 수 있음
    - 이럴 경우 0~255까지 되던 것이 0~127과 128~255로 작게 두 개가 분할이 됨
    - 즉, 192.168.0.**0**/25와 192.168.0.**128**/25 두 개가 된 것
- 이렇게 주소 범위를 더 작은 범위 서브넷으로 분할하는 것을 **서브네팅**(Subnetting)이라고 함

- 퀴즈
    - 196.0.10.0/24 를 2개의 서브넷으로 분할한 CIDR 블록 표기
        - 196.0.10.0/25
        - 196.0.10.128/25
    - 196.0.10.0/23 을 3개의 서브넷으로 분할한 CIDR 블록 표기
        - 196.0.10.0/24
        - 196.0.10.0/25
        - 196.0.10.128/25