# ■ 2주차 (9월 14일)

# 소프트웨어 개발 주기와 모델링

## 전문적인 소프트웨어

- 전문적 소프트웨어 개발은 독립된 **다른 사용자를 위해** 소프트웨어를 개발하는 것
- 또한, 1인 개발이 아닌 **팀 단위의 개발**을 의미함
    - 구성, 협업의 구조, 프로젝트 매니저, 개발자 등이 필요함
- 좋은 소프트웨어를 만들기 위해서이며, 그걸 판단하는 기준은 **품질(Quality)**이다.
- 품질의 중요 요소 4가지
    1. 수용성 : 사용자가 이해하기 쉽고 유용하며 호환이 좋아야 함
    2. 신뢰도와 보안 : 소프트웨어에 자체적이거나 외부의 문제가 생기더라도 물리/경제적 피해 X
    3. 효율성 : 불필요한 리소스 사용 최소화, 일정한 응답속도와 성능을 보장해야 함
    4. 유지보수성 : 소프트웨어의 기능 변경에 대응할 수 있게 아키텍처가 설계되어야 함

## 소프트웨어 엔지니어링

- 소프트웨어 : 컴퓨터 프로그램**과** 그와 관련된 문서와 라이브러리 등을 포함하는 개념
    - 소프트웨어는 특정 고객 혹은 범용적 목적으로 개발될 수 있다.
    - 전문가, 엔지니어 입장에서 소프트웨어는 프로그램 뿐만 아니라 관련 매뉴얼, 소개서 포함
- 소프트웨어 엔지니어링 : 초기 구상에서부터 운영, 유지보수 과정 등 전문적인 소프트웨어 개발에 필요한 **규율**
- 소프트웨어 엔지니어링의 내용
    - 소프트웨어의 **명세, 개발, 검증, 개선**
- 좋은 소프트웨어의 구성 요소
    - **기능** 제공, 요구 **성능** 보장, **유지보수**가 가능, **신뢰** 가능, **사용성**이 우수
- 적절한 소프트웨어 개발 주기 SDLC(Software Development Life-Cycle)
    - 시스템의 요구분석부터 유지보수까지 전 공정을 체계화한 절차
    - SDLC 모델은 여러 형태가 존재. **폭포수 모델**과 **애자일 모델**이 실무에 많이 활용됨

## SDLC

- 모든 개발 주기에서 필수적으로 수행하는 활동
    - 명세 : 소프트웨어가 제공해야 할 기능과 제약 명시 (요구사항 분석, 설계)
    - 개발 : 명세에 따라 소프트웨어 개발 (개발, 유닛 테스트)
    - 검증 : 명세에서 요구되는 기능에 제대로 구현되었는지 검증 (통합 테스트, 성능 테스트)
    - 개선 : 요구사항의 변경을 소프트웨어에 반영 (운영 및 유지보수)
- 4가지 필수적 활동을 어떤 방식으로 수행하는지에 따라 개발 주기를 구분할 수 있음
    - 계획 주도 모델 (개발 주기의 활동들을 **전부 계획**하고, 진척도를 측정, **폭포수 모델**)
    - 애자일 모델 (소프트웨어 일부분에 대해서 설계-구현-테스트-배포를 **반복적**으로 수행)
    - 계획 주도 모델과 애자일 모델은 서로 상반됨

### 폭포수  모델 (계획 주도 모델)

- 1970년대 군사 무기 시스템을 만들던 공학적 절차에서 고안
- 고정된 요구사항을 갖고 전체 개발 절차가 진행되는 방법론
- 이론적으로 앞 단계가 완료되어야 다음 단계로 갈 수 있음. 전체 프로세스가 진행되어야 이전 프로세스를 재수행 할 수 있음
- 요구사항 분석 → 시스템 및 S/W 설계 → 구현 및 유닛 테스트 → 통합 및 테스트 → 유지보수
    - 요구사항 분석 : 제공하는 서비스와 제약, 목표 수립, 명세 구체화
    - 시스템 및 S/W 설계 : 요구사항을 S/W 형태로 할당, 전체 시스템 아키텍처를 수립
    - 구현 및 유닛 테스트 : 실제 프로그램 유닛들을 제작, 유닛 테스트를 통해 검증
    - 통합 및 테스트 : 프로그램의 유닛들을 하나의 시스템으로 통합하고 테스트
    - 운영 및 유지보수 : 일반적으로 가장 긴 단계. 초기 단계에 없던 에러 발견하고, 코드 개선, 새로운 요구사항을 발견하면서 시스템을 개선
- 단점
    - 변경사항이 발생해도 개발 진행중에는 요구사항에 반영 불가능
    - 문서가 아닌 비공식적 팀 내 대화가 많고, 따라서 변경사항이 자주 발생하는 경우엔 적합X
    - 요구사항 분석에서 설계에 이르기까지 문서화해야 할 내용이 오히려 부하로 작용
    - 설계에서 고려되어야 했던 내용들이 파악되지 못하고 많은 양이 진행된 후에 파악되는 문제
- 적절한 사용
    - 요구사항의 이해가 쉽고 변경이 잘 발생하지 않는 경우에 적합함
    - 예를 들어 RDBMS 개발 (기능 명세가 표준으로 정의된 것들이 대부분)

### 애자일 모델

- Agile : 날렵한, 민첩한, 재빠른, 기민한
- 소프트웨어를 최단시간에 배포할 수 있도록 불필요한 행위 배제, 요구사항 변화에도 빠르게 대응
- 계획 주도 모델의 단점을 극복, 설계와 문서와보다 프로그램 자체에 집중
- 애자일 모델에 속하는 다양한 종류의 방법론이 제시 (익스트림 프로그래밍, 스크럼)
    - 스크럼 : 애자일 개발 방법론 중 한가지
    - 제품 기능 목록 작성 - 스프린트 계획 회의 - 스프린트 수행을 반복 - 최종 제품 개발
    - 한 스프린트가 잘 구현되도록 스크럼 마스터가 별도로 존재
    - 스프린트 하나가 끝나면 스프린트를 검토 회의, 기능 추가 시 회고. 회의가 많음
- 애자일 모델의 공통적인 특징
    - 전체 기능 리스트를 작성
        - 개발할 기능 선택
        - 기능 명세 구체화
        - 구현 및 테스트
        - 기능 통합 및 테스트
        - 개발 내용 리뷰
        - 위 내용을 계속해서 반복
    - 모든 기능 구현시 제품 발매
- 이렇게 애자일 모델로 개발하는 경우 대개 Jira라는 툴을 사용
- 단점
    - 임베디드 시스템이나 규모가 크고 복잡한 시스템을 만들 땐 문제 발생
    - 명세를 확정짓질 못해서 법적 계약서에 내용 명시가 어려울 수 있음
        - 주기가 반복하면서 요구사항 자체가 변경되기 때문. 계약 당시와 다른 요구사항이 포함되거나 빠지는 경우가 발생
    - 신규 소프트웨어 개발에는 적합하지만 유지보수에는 부적절함
        - 지속적으로 고객을 애자일 프로세스에 포함해야 하는데, 참여 유지가 매우 어려움
        - 문서가 적어서 이후 개선 작업 수행하는 팀이 소프트웨어 개발 팀이 아니면 유지보수가 불가능한 상태가 될 수도 있음

---

- 따라서, 실제 업무에서는 계획 주도 모델과 애자일 모델의 방법론 요소를 **필요에 따라 부분적으로 적용**하기도 함.
- 모든 요구사항이 미리 정의되어 있고, 규제와 법률에 따라 특정 기능과 보안 요구사항이 명확하게 정의되어 있는 경우 → 폭포수 모델
- 스타트업에서 초기 아이디어만 있고, 피드백을 받아 지속적으로 제품을 개선하려고 한다 → 애자일 모델
- 안전과 보안이 매우 중요하고 모든 요구사항과 테스트 절차가 미리 정의되어 있음 → 폭포수 모델
- 소셜 미디어 플랫폼, 시장의 변화와 경쟁사의 움직임에 따라 빠르게 기능 추가 및 변경 필요 → 애자일 모델
- 대학 기존 시스템과 호환성, 학생들의 요구사항이 미리 정의되어 있음 → 폭포수 모델
- 게임 개발사 새로운 게임 출시, 인기에 따라 지속적으로 콘텐츠 업데이트 및 피드백 → 애자일 모델

---

## 요구사항

- 요구사항 분석 : 실제 개발 과정에서 내가 만들어야 할 소프트웨어의 요구사항 정의
- 요구사항 명세 : 제공해야 할 서비스의 기능적 요구사항을 시스템 모델링 기법으로 작성
- 간단하게 할 땐 모델링 없이 머리속으로 설계하고 바로 개발할 수 있음. 하지만 항상 잘 동작하지 않으며, 전체 시스템 설계가 틀어지는 경우가 발생할 수 있음.
- 요구사항 분석과 모델링은 시스템의 이해를 높이고, 의사소통을 통해 불필요한 변경 최소화.
- 시간이 지나면 코드만으로 파악하지 못할 사실들을 문서화된 내용으로 기억할 수 있음.

- 요구사항 : 시스템이 제공해야 할 **서비스**와 동작 중에 지켜야 할 **제약사항**을 의미한다.
    - 육하원칙에 따라 작성되어야 전달력 높은 문서가 될 수 있음
- **사용자 요구사항** : 기능 및 제약사항을 문장이나 다이어그램을 통해 고차원적이고 추상적 표현
- **시스템 요구사항** : 기능 및 제약사항의 세부적인 명세를 구조화된 문서나 다이어그램으로 작성

### 기능과 제약사항

- 시스템이 제공해야 할 기능을 기능적 요구사항이라고 부름
    - 예를 들어, 과목들의 목록을 항상 조회할 수 있어야 하며 8자리 고유의 숫자 값으로 구분
    - 기능 딱 하나에서만 서비스해야할 요구사항
- 시스템이 전체에서 지켜야 할 제약사항을 비기능적 요구사항이라고 부름
    - 예를 들어, 웹 브라우저를 통해 접근하며, 학생 입력이 몰리면 초당 100건 처리 보장
    - 환경적 요구사항, 성능 요구사항 등 기능 아닌거

### 요구사항 명세

- 사용자 요구사항과 시스템 요구사항을 문서로 작성하는 행위
- 사용자 요구사항은 기술적 배경지식 없는 최종 사용자도 이해할 수 있어야 함
- 시스템 요구사항은 기술적인 정보들이 포함되어도 무방
    - 개발자는 주로 시스템 요구사항을 작성하게 됨
    - 시스템 요구사항은 자연어로 가술하거나, 도표로 표기하는 등 이해하기 쉽게 써야 함

### 요구사항 문서

- MRD : 시장 요구사항 문서
    - 시장에서 고객의 요구와 경쟁 상황, 시장의 기회 등에 대해 개발의 방향과 전략을 정의
    - 시장 설명, 요구사항, 시장 크기, 성장 예층, 경쟁 분석, 위치 및 가치 제안, 비용
- PRD : 제품 요구사항 문서
    - MRD를 기반으로 제품의 구체적인 기능과 기술적 요구사항을 정의, 개발팀이 구현 시 참조하는 핵심 문서. PM(기획자)가 작성하는 기능에 대한 디테일
    - 기능적 요구사항, 인터페이스 요구사항, 통합 요구사항, 제품의 제약 사항

## 시스템 모델링

- 시스템 요구사항을 도표  기반의 모델링 기법을 활용해 모델을 만드는 것
- UML : 시스템을 모델링하기 위한 13가지 표기법들의 집합 (High/Low Level 모델링)

# ■ 3주차 (9월 21일)

# High-Level 모델링, Low-Level 모델링

### High-Level 모델링

- Activity Diagram : 비즈니스 프로세스, 워크 플로우, 시스템 동작 흐름 (2주차 과제)
- Use case Diagram : 시스템의 주요기능과 사용자 관점에서 상호작용 표현

### Low-Level 모델링

- Sequence Diagram : 시스템 내 객체 간 상호작용과 메시지 전달 순서 표현
- Class Diagram : 시스템 데이터의 구조와 구조간 관계 표현
- State Diagram : 객체의 생명주기 동안 상태 변화에 대해 표현

## 액티비티 다이어그램

- 시스템이 적용될 업무의 흐름을 행위(Activity) 단위로 절차를 표현하는 다이어그램
- 제어 흐름을 표현할 수 있음
- 시작점 / 액티비티 / 결정 / 결합 분합 노드 / 액션 플로우 / 종료점
    - [draw.io](http://draw.io) 사이트에서 쉽게 그릴 수 있음

### Swimlanes

- High-Level 모델링 : 시스템의 전체적 구조와 기능 표현
- 액티비티 다이어그램을 확장한 것이 **스윔레인**
- 시스템이 적용될 업무의 흐름을 나타내는 다이어그램인데, 업무의 흐름이 **엔티티들 간에 완벽히 분리되어 있음**
- 스윔레인 전용 심볼이 따로 존재
    - 시작 / 종료 심볼
    - 프로세스 심볼
    - 순환 심볼
    - 출력 심볼
    - 조건 심볼 또는 결정 심볼
    - 위 심볼을 스윔레인 심볼 표에 위치시켜 그리는 것

## 유즈 케이스 다이어그램

- 사용자와 시스템 사이의 상호작용(Interaction)을 나타내는 다이어그램
- 사용자와 시스템 등 행위의 주체가 되는 대상을 행위자(Actor)라고 함
- 시스템을 사용할 때 발생할 수 있는 행위를 나열, 어떻게 처리되는지 자세하게 표현하지는 않음

## 클래스 다이어그램

- 로우 레벨 모델링 : 시스템의 구체적인 구현 세부사항 표현
- 클래스 다이어그램 : 객체지향 시스템 모델을 구현할 때 사용하며, 클래스들 간의 **관계**를 링크(Link)로 표현
- 실세계를 클래스로 변환하는 과정
- 클래스 심볼
    - 클래스 이름, 속성, 연산 또는 메소드 정보가 담겨있음
    - 두개 이상의 클래스들 사이에 **관계**가 있음을 Link로 이어 표현
    - 관계에 대한 설명을 **주석**으로, 동사형으로 표현

### 일반화

- 객체지향에서의 **상속**과 유사한 개념
- 학생 → A 동아리 회원
- 학생 → 도서관 회원
    - 학생은 학번, 이름, 나이 등의 정보가 있고, 도서관 회원은 거기에 추가로 도서관 ID와 대여한 도서 등이 나타남
    - 도서관 회원이나 동아리 회원은 학생의 특수한 경우
- 일반화의 장점 : 변경사항 발생 시, 모든 하위 클래스를 변경할 필요 없이 상위 클래스만 고려하면 일괄적으로 변경됨
- 상속받는 대상이 어떤 클래스로부터 상속받을지를 가리킴
    - 자식 → 부모

### 합성

- 두 클래스 사이에 **의존성이 존재**함을 나타냄
- 의존성은 한 쪽 클래스에서 다른 쪽 클래스로 발생하게 됨
    - 예를 들어 작품 정보가 존재하지 않다면, 도서도 존재하지 않는다.

### 집합

- 합성과 동일하나 차이점이 존재
- **의존성이 약해** 한 쪽이 없어지더라도 다른 한 쪽에 영향을 미치지 않음.
    - 도서관 회원과 대여 도서

## 시퀀스 다이어그램

- 시스템 내 객체 간 **상호작용**과 메시지 전달 순서 표현
- 컴포넌트들 간의 상호작용을 표현하며, 컴포넌트를 무엇으로 하느냐에 따라 high-level과 low-level 모두 표현 가능
    - 시스템 사용자와 시스템 사이의 상호작용 → high-level
    - 객체 간의 연산 호출 관계를 표현 → low-level
- 심볼의 종류가 다양하여 표현 가능 상호작용이 매우 많음

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c774ef96-3ce2-4a6d-9606-5cca39ae2044/73cb746e-deef-4144-b785-2410daa7062a/Untitled.png)

## 스테이트 다이어그램

- 객체가 특정 이벤트에 대해 어떻게 반응하는지를 모델링
- 둥근 모서리 사각형의 형태의 상태와 어떤 반응을 보이는지를 나타내는 화살표를 그어 모델링