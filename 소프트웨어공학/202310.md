# ■ 4주차 (10월 5일)

- 클래스  다이어그램
    - 하얀 삼각 화살표 : 일반화 (부모로부터 상속받아 생성)
    - 하얀 마름모 화살표 : 집합 (부모가 사라져도 활용 가능)
    - 검은 마름모 화살표 : 합성 (부모가 사라지면 본인도 파괴)

## 인공지능 기초

- 인공지능은 요즘 언어 모델 / 음성 / 비전 기술로 나뉜다
- 인공지능 : 인간의 학습 능력, 추론 능력, 지각 능력을 인공적으로 구현하는 기술
    - 인간의 뇌에 존재하는 시냅스와 인간이 가진 정보량은 비례관계
    - 시냅스를 따라 만든 AI 파라메터가 많을 수록 성능이 향상됨
- AI는 ML(머신 러닝)과 DL(딥 러닝)을 모두 포함한다

### 머신 러닝

- 머신 러닝은 컴퓨터가 명시적으로 프로그래밍되지 않아도 학습할 수 있는 능력을 갖추도록 하는 알고리즘과 기술의 집합.
- 딥러닝을 포함하는 넓은 범위를 가지며, 딥러닝 이외에도 다양한 학습 알고리즘을 포함
- 대표 기술 : SVM, Logistic Regression 등 (AI로는 여겨지지 않는 기술)

### 딥 러닝

- 머신 러닝의 한 분야로, 인공 신경망을 기반으로 복잡한 비선형 문제를 해결하는 방법론
- 대량의 데이터와 계산 능력을 요구, 많은 데이터와 모델의 크기가 성능을 좌우함
- 대표 기술 : CNN, RNN, Transformer 등 (AI라고 여겨지는 기술)

### 딥 러닝 모델

- 입력층, 다계층으로 구성된 은닉층, 출력층을 이루고 있는 모델
- 입력층 1개, 은닉층 N개, 출력층 1개

### 인공지능 모델의 개발 과정

- 인공지능 모델 개발 과정
    - 다량의 데이터를 사전 학습하여 사전 학습된 모델 생성 (GPT의 P)
    - 태스크맞춤형 데이터를 넣은 파인 튜닝을 통해 맞춤형 모델 생성
- 순전파(Forward Propagation) 와 역전파(Back Propagation) 를 통한 모델 학습 과정
    - 순전파 : 데이터에 가중치를 곱하여 예측치를 계산
    - 역전파 : diff(예측치 - 정답)을 활용하여 가중치 업데이트
- 모델 학습 과정
    - 데이터 수집 및 전처리 → AI 모델 학습 → AI 모델 패키징 → AI 모델 검증 → 실제 환경에 모델 적용 → 유지보수 및 모니터링

- 인공지능 모델 개발에 활용되는 데이터 형태
    - 정형 데이터 : 구조화된 형태로 값이 존재 (DB 등)
    - 반정형 데이터 : 구조화된 형태지만 연산이 불가능 (XML, JSON 등)
    - 비정형 데이터 : 형태가 없고, 연산도 불가능 (텍스트, 영상, 음성 등)

### 인공지능 기술의 발전 현황

- 인공지능 모델 개발에 활용되는 기술은 오래전부터 개발되기 시작함
    - 1940년부터의 전자두뇌, 단일계층 신경망 ~ XOR 등등
- 2012년 알렉스넷부터 인공지능 기술이 발전도기 시작
- GPU의 발전에 따라 인공지능이 점점 성공을 거둠
    - GPU 사용률이 높을 수록 인공지능의 에려율이 줄어듦
- 인공지능 모델 학습용 데이터가 날이 갈수록 방대해짐
- 그에 따라 인공지능 모델의 크기가 540빌리언까지도 커짐

---

## 자연어처리 (NLP) 기초

- 인간과 매우 유사한 방식으로 텍스트 및 음성 언어를 이해하는 능력 부여
- 자연어 데이터는 사람이 알아보긴 쉽지만 그대로 기술에 활용하긴 어려우므로, 전처리 과정을 통해 벡터화된 정보로 활용
    1. 토큰화 (단어나 문자를 분할)
    2. 단어 집합 생성 (중복 제거, 고유 인덱스 부여)
    3. 정수 인코딩 (고유한 정수를 매핑)
    4. 패딩 (동일한 길이로 맞춤)
    5. 벡터화 (원핫 인코딩, 워드 임베딩 등으로 자연어 표현)
- 원핫 인코딩 (One-hot Encoding)
    - 1 또는 0으로 구성된 벡터, 단 하나의 값만 1이고 나머지 다 0인 벡터
- 단어 임베딩 (Word Embedding)
    - TF-IDF (횟수기반 임베딩 대표방법)
    - Word2Vec (추론기반 임베딩 대표방법)
- 원핫 벡터와 임베딩 벡터의 차이점
    - 원핫 벡터
        - 고차원 (단어 집합의 크기)
        - 다른 표현 : 희소 벡터의 일종
        - 표현 방법 : 수동
        - 값의 타입 : 0과 1
    - 임베딩 벡터
        - 저차원
        - 다른 표현 : 밀집 벡터의 일종
        - 표현 방법 : 훈련 데이터로 학습
        - 값의 타입 : 실수
- 인공신경망을 이용한 자연어 처리 : RNN
    - 언어 데이터는 순서 정보를 포함하고 있으므로, 이전 정보와 향후 정보를 반영하는 RNN 계열 모델을 사용하여 자연어 처리에 활용함
    - hidden layer를 활용해 한 문자가 주어지면 다음 순서의 문자로 갈 수 있도록 모델을 설계
- 다양한 입/출력 형태를 구성하여 목적에 맞게 활용
    - one - to one
    - one - to - many
    - many - to one
    - many -to many
- RNN의 기울기 소실 문제
    - 딥러닝 특성상 히든 레이어의 수가 많고, 반복되는 단계가 깊어질수록 입력층에 가까운 벡터들이 제대로 학습되지 못함
    - 따라서 깊이를 무한정으로 둘 수 없었음
- 위 문제를 해결하는, 언어에 대한 정보를 더 잘 학습하기 위한 LSTM, GRU
    - 장기의존성 문제 해결을 위해 몇 가지 기술을 추가하여 자연어 처리에 활용
    - 과거 정보를 얼마나 유지할지, 새로 입력된 정보는 얼만큼 활용할지, 두 정보를 계산하여 나온 출력 정보를 얼마만큼 넘겨줄지 결정
    - 그럼에도 데이터가 길어지면 잊어버리는 문제는 여전함
        - → 트랜스포머의 등장 (GPT의 T)

---

## LLM (Large Lange Models)

- LLM : 수십억 또는 수조 개의 파라메터를 포함하는 대규모 언어 모델
    - 단순히 엄청나게 많은 데이터를 학습한 AI 모델
    - 대표적으로 OpenAI의 GPT-3

### 트랜스포머

- 기존 자연어처리 모델 구조와 달리, 다양한 인코더 - 다양한 디코더 형태로 구성된 구조
- 셀프 어텐션, 포지셔널 인코딩을 통해 처리 성능 향상
    - 단어와 단어 사이의 연관관계, 단어의 순서와 위치정보 학습
- 트랜스포머 구조를 활용하는 기술 탄생 : BERT, GPT
- BERT
    - 트랜스포머의 인코더 구조를 활용한 언어모델, 사전학습된 파인튜닝 단계
    - 사전학습된 거대 모델들은 최근 Foundation Model이라고 불림
    - 성능 향상을 위한 학습 방법들을 제안
        - 중간중간 MASK 지정, 비어있는 공간 채워 모델의 성능 향상
        - 자연어 문장의 이빨 하나를 빼놓고 입력하면 그 이빨을 추론
- GPT
    - 트랜스포머의 인코더 - 디코더 구조를 모두 활용하는 거대 언어모델
    - ChatGPT를 통해 최근 알려졌지만 2018년도부터 지속되어 개발
    - GPT-3는 175빌리언의 텍스트를 썼지만, GPT-4부터는 알려주지 않음
    - GPT 개발용 Task (GPT뿐만 아니라 다양한 인공지능에서 쓰임)
        - Zero-shot : 학습되지 않은 처음 보는 문제를 맞추는 Task
        - One-shot : 하나의 정답만 보여주고 문제를 맞추는 Task
        - Few-shot : 몇 가지 답을 보여주고 문제를 맞추는 Task
    - GPT를 잘 쓰려면 Few-shot Task로 문제를 내면 원하는 답이 더 잘 나옴
        - 만들고자 하는 코드에 대한 지시를 하고, 잘 만들어진 코드 예시 또는 포맷을 함께 제공
    - GPT의 대항마 LLaMA
        - 라마는 ChatGPT-3에 비교하면 모델의 크기는 상당히 줄고 성능이 개선
        - 오픈소스로 공개하여, 업스테이지 등 여러 기업들이 라마를 기반으로 개발중

## 생성 모델 활용 사례

- 언어 생성
    - 자연어 생성, 코드 작성
- 이미지 생성
    - GAN 또는 SD기반의 모델을 사용하여 이미지 / 동영상 생성
    - 딥페이크
- 음악 및 오디오 생성
    - 음악 생성 및 음성 생성
- 번역, 광고
- AUTO-GPT
    - 인간처럼 생각하고 행동 무한반복하는 장기행동
    - 개발환경 구축, 라이브러리 설치, 코딩 등등
    - 심지어 피자가게 가서 피자 주문해줌


# ■ 5주차 (10월 12일)

- ChatGPT를 활용해 flask 도서관 웹사이트 만들기

# 소프트웨어 품질

## 소프트웨어 품질의 특징

- 소프트웨어 품질은 눈으로 확인하거나 절대평가가 어려움
- 기대치가 굉장히 올라가고, 품질 수준이 점점 높아짐
- 품질은 이해관계자에 따라 요구사항 및 수준이 상이함
    - 운영자, 개발자, 구매자, 사용자
- 소프트웨어의 품질이 좋아지면
    - 사용자가 만족하는 품질은 품질좋은 제품을 만든다.
    - 시장에서의 선호도가 향상하고, 기업의 이익 창출이 증대한다.
- 이해관계자 관련 품질 요소
    - 스폰서 : 낮은 비용, 적용성, 재사용성, 비용 효율성
    - 사용자 : 정확성, 신뢰성, 사용성, 낮은 비용
    - 유지보수자 : 가독성, 코딩 표준 준수성, 프로그램 구조, 검증 가능성, 문서화

## 소프트웨어의 품질 요소

- 품질 요소는 매우 다양하여 모든 요소를 만족시키기 어려움.
- 크게 품질 요소는 외적 품질과 내적 품질로 나눌 수 있다.
    - **외적 품질** : 겉으로 드러나는 품질. 정확성, 효율성, 비용, 신뢰성 등등.
    - **내적 품질** : 전문가들이 보는 품질. 코딩 규칙, 복잡도, 재사용성, 가독성, 유지보수성 등등.

### **외적 품질요소**

- 정확성 : 주어진 명세서의 내용을 하나씩 테스트하여 원하는 결과를 생성하는지 판단
- 신뢰성 : 소프트웨어를 사용하는 동안 나타나는 오류 발생 정도와 치명도
- 견고성 : 사용자가 제시한 요구사항 명세에 정의하지 않은 조건이나 환경에도 합리적으로 동작해야 견고하다. 항공기 제어 소프트웨어 등 안전 담보 임무 수행 시스템에서 중요.
- 성능 : 소프트웨어 효율성. 사용되는 메모리의 양, 실행 시간 등이 척도
- 사용자 친숙성 : 소프트웨어가 사용하기 편리한가를 나타내는 품질 요소. 편의성 지원 기능 제공
- 가용성 : 서버, 네트워크, 프로그램 등이 정상적으로 사용 가능한 정도. 소프트웨어를 정상적으로 사용 가능한 시간을 소프트웨어 전체 운영시간으로 나눈 값이 클수록 가용성이 높아짐
- 보안성 : 외부의 공격에도 소프트웨어가 막아낼 수 있도록 구현. 취약점 개수나 사고 통계, 보안 취약으로 드는 연간 손실액 등이 척도

### 내적 품질요소

- 검증 가능성 : 소프트웨어가 지닌 속성이 올바르다는 것을 안전하게 확인 가능. 정형 검증과 테스트로 평가. 다양한 정형 기법을 혼합하거나 테스트를 통해 시스템 속성 확인.
    - 정형 검증 : 검증 대상을 형식 언어로 표현, 모델의 상태 전이를 시뮬레이션함으로 동작한다는 것으로 증명
    - 테스트 : 정확한 동작 확인을 위해 다양한 시나리오 준비, 테스트 데이터를 이용해 실행
- 유지보수성
    - 수정 유지보수 : 개발된 소프트웨어를 사용하는 동안 오류가 발생하는 경우
    - 적응 유지보수 : 소프트웨어 운영 조건에 대한 변화를 수용
    - 완전 유지보수 : 사용중인 소프트웨어 가독성, 이해성을 높이는 재구조화
    - 예방 유지보수 : 소프트웨어가 정확히 동작할지 테스트. 임무 중심과 안전 중심 소프트웨어
- 재사용성 : 새로운 소프트웨어 개발 시 기존 소프트웨어 컴포넌트를 사용하는 정도
- 이식성 : 얼마나 다양한 하드웨어 플랫폼을 지원하는가와 다양한 버전의 소프트웨어 플랫폼 지원
- 생산성 : 외적 품질 요소의 성능의 속성을 적용, 주어진 시간 내에 얼만큼 성과를 내고있는가
- 상호 운용성 : 서로 다른 소프트웨어들이 협업을 수행할 수 있는 능력
- 가시성 : 개발 단계의 상태 정보와 산출물 등을 체계적으로 유지 관리. 의사결정과 회의가 가능

### 프로세스 품질요소

- 프로세스 모델 적합성 : 어떤 프로세스 모델을 적용할 것인가 (어떤 방식으로 개발할 것인가, 애자일, 워터폴 개발 등)
- 개발 방법론 적합성 : 객체지향, 구조적, 정보공학 방법론 등
- 도구 적합성 : 개발 과정에 많은 지원 도구가 개발 환경에 적합한지, 팀 개발을 지원하는지
- 표준 준수성 : 선택한 표준이 적절한지, 잘 준수하여 프로젝트가 진행되는지
- 프로젝트 데이터 관리 수준 : 상세 데이터가 정보 저장소 저장, 프로젝트 내에서 예측 활동에 따라 활용할 수 있음.

## 소프트웨어 품질 관리 프로세스

1. 준비 단계 : 품질 관리 활동 공식화, 팀과 역할 정의. 표준, 도구, 환경 설정
2. 척도 조정 단계 : 측정할 품질 요소를 결정, 이를 적용할 대상 정의. 품질 측정 계획서에 기재
3. 측정 단계 : 계획에 따라 데이터 수집 분석, 필요한 경우 데이터 발견 및 새로운 척도 적용
4. 평가 단계 : 측정된 품질 요소의 정확성과 품질 수준 평가. 측정 과정 올바름 점검, DB 저장
5. 관리 단계 : 조직 차원에서의 품질 및 기술 관리 프로세스 실행. 표준 선택, 가이드라인 제공

## 소프트웨어 형상관리

- 전문적 소프트웨어 개발 과정은 팀 개발 단위 → 통합
- 공통 부분 통합(Merge)시 발생하는 문제 충돌(Conflict)
    - 통합 과정에서 조율을 통해 충돌에 대한 정리가 필요
- 소스코드의 어디가 어떻게, 왜 변경되었는지 추적해야 함
- 소프트웨어를 안정적으로 보관할 장소가 필요함
- **소프트웨어 형상관리(SCM)** : 개발 및 사용 과정에서 지속적으로 변화하는 소프트웨어를 체계적으로 관리하기 위한 정책, 절차, 툴
    - 버전 관리 : 시스템 컴포넌트들이 여러 버전을 가질 수 있고, 변경사항이 서로 간섭이 없음. (Git)
    - 시스템 빌딩 : 소스코드를 컴파일, 링킹하는 활동. 안정적이고 일관된 빌드 환경. (Jenkins)
    - 변경 관리 : 출시된 소프트웨어 제품에 대한 변경 요청을 기록, 분석, 결정. (JIRA)
    - 출시 관리, 배포 관리 : 정식 출시를 준비하고 출시된 제품들의 버전 관리. 고객이 사용하기 위한 버전을 체계적으로 관리하고 고객 지원을 효율적으로 수행 (Docker, Kubernetes)

### Git

- **Git** : 소프트웨어 소스코드의 버전 관리 툴
- Gitbash를 사용하여 활용
- 리포지토리 : git에서 소프트웨어의 소스코드를 저장하는 단위
    - git clone 방법 : github에 있는 리포지토리를 로컬 PC에 동기화
    - 기존에 소스코드가 이미 있는 경우, git config, git init 방법 : 기존 코드가 존재하던 디렉토리를 리포지토리와 연결
- 버전 관리를 위해 이미 출시된 제품에 대한 관리. git의 태그 기능을 사용해 관리
- 원격 리포지토리에서 클론해오면 로컬 PC에서 사용이 가능
- 여러 개발자들이 각자의 branch에서 개발을 진행하고, 통합을 진행
- Git 주요 명령어
    - git init : 새로운 Git 저장소 초기화
    - git clone : 원격 저장소를 로컬에 복제
    - git add : 변경된 파일을 스테이징 영역에 추가
    - git commit -m “commit message” : 스테이징 영역의 변경사항을 저장소에 기록
    - git push : 로컬의 커밋을 원격 저장소에 업로드
    - git pull : 원격 저장소의 변경사항을 로컬로 가져옴
    - git status : 작업 트리의 상태를 확인
    - git diff : 두 커밋, 브랜치, 또는 작업 트리 간의 차이점을 표시
    - git log : commit 이력을 조회
    - git show : 특정 커밋의 메타데이터와 변경 내용을 보여줌

# ■ 6주차 (10월 19일)

# Githib 활용

- 실습 전 윈도우에 계정 정보가 두 개 이상 존재하지 않는지 확인
- 브런치를 master에서 main으로 변경하고 실습

## Git 기본 기능

1. 로컬 워크 스페이즈에서 여러가지 작업을 실행
2. git add를 통해 작업 내용을 stage하여 스테이징 영역에 반영
3. git commit을 통해 스테이징 영역에 반영된 내용들을 로컬 리포지토리에 업로드
4. git push를 통해 원격 리포지토리에  내용을 반영

### git bash로 작업하기

- 윈도우에서 깃허브 사용을 위해선 gitbash를 설치해야 함
- git bash 실행 후 계정 설정을 통해 작업 관리를 해야 함

```bash
git config --global user.name "Your Name"
git config --global user.email you@example.com
```

- 내 계정과 이름을 남겨놓고 작업을 해야 함
- 이후 깃허브에 연결하기 위한 로그인 인증 창이 뜨면 로그인해야 연동됨

### git repository를 사용하는 방식

- 방법 1 : github에 있는 리포지토리를 local PC에 git clone으로 동기화 후 작업
- 방법 2 : 기존 코드가 존재하던 디렉토리를 repository와 연결
    - git init - git remote add origin - git push
- git 원격 리포지토리에서 code 버튼 누르면 나오는 http URL을 활용

### git 기본 명령어

- git init : 새로운 Git 저장소 초기화
- git clone : 원격 저장소를 로컬에 복제
- git add : 변경된 파일을 스테이징 영역에 추가
- git commit -m “commit message” : 스테이징 영역의 변경사항을 저장소에 기록
- git push [remote-name] [branch-name] : 로컬의 커밋을 원격 저장소에 업로드
- git pull [remote-name] [branch-name] : 원격 저장소의 변경사항을 로컬로 가져옴

### git 파일 상태 관리

- git status : 작업 트리의 상태를 확인
- git diff : 두 커밋, 브랜치, 또는 작업 트리 간의 차이점을 표시
- git log : commit 이력을 조회
- git show : 특정 커밋의 메타데이터와 변경 내용을 보여줌

## Git 활용

- 소스코드 관리체계 (브랜치 전략)
    - 소스코드 관리와 협업을 위해 중요한 요소
    - 프로젝트의 특성, 협업방식, CI/CD 구조에 따라 적절한 전략을 설정해야 함
    - 버전 관리
        - master 혹은 main 브런치는 언제든지 배포가 가능한 버전으로 유지
        - 개발 기능이 추가되면 Develop 브런치에 추가
        - 자잘한 업데이트와 공유는 Feature 브런치에 추가
    - 스프린트 관리
        - 시작부터 끝까지의 스프린트들을 설계
        - 어느 브런치에서 무슨 작업을 하고, 언제 통합을 할지 등의 전략 설정

## CI/CD 파이프라인 내 소스코드 관리

- CI (Continuous Inntegration) : 코드를 통합하는 프로세스
- CD (Continuous Deployment / Delivery) : 배포를 위한 준비
- 코드 통합과 배포 자동화, 효율적인 협업(브랜치 전략), 빠른 피드백 루프

### 브랜치 전략 (Git-flow)

- Master 브랜치 : 배포 가능 상태
- Develop 브랜치 : 다음 버전을 개발하는 브랜치
- Feature 브랜치 : 기능 개발 및 버그수정작업용 브랜치. 완료 시 Develop 브랜치에 통합
- Release 브랜치 : 배포 준비 브랜치 (버전번호 지정, 버그 수정, 문서 업데이트)
    - 완료 시 Master로 병합 → Develop으로 병합
- Hotfix 브랜치 : 긴급이슈 수저어 브랜치로 수정 후 master와 develop에 병합
- 2020년 Github에서 기본 브랜치명을 master에서 main으로 변경되었고, 기존 소스들은 master로 작성되어있는 경우도 많음.