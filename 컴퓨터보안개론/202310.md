# ■ 5주차 (10월 10일)

# 웹과 HTTP

### 웹의 이해

- 팀 버너스 리가 연구 목적으로 1989년 CERN에서 시작
- 연구 당시엔 웹을 ‘하이퍼 텍스트 프로젝트’ 라고 부름
- 현재 웹 문서로 가장 많이 쓰이는 하이퍼 텍스트 스크립트 언어는 HTML
- 웹은 수많은 보안 취약점이 내재되어 있어 해킹에 취약한 집중적인 공격 대상

### HTTP 프로토콜

- 여러 프로토콜 중 가장 많이 쓰이는 프로토콜은 HTTP
- HTTP 0.9버전 (초창기) 연결 과정
    1. 서버가 준비 상태
    2. 클라이언트는 읽고자 하는 문서를 서버에 요청
    3. 서버는 웹 문서 중에서 요청받은 것을 클라이언트에 전송
    4. 전송 성공 (200) 반환 시 연결 해제
    - 이 방법은 요청할 때마다 매번 연결을 해야하므로 비효율적
- HTTP Request
    - GET 방식 : 가장 일반적인 형태, 요청 데이터의 인수를 URL로 전송
        - 데이터가 주소 입력란에 표시되므로 최소한의 보안도 유지하지 않는 취약한 방식
    - POST 방식 : URL이 아닌, HTTP 헤더에 데이터를 전송
        - 다른 사용자가 링크로 해당 페이지를 볼 수 없음
        - 게시판의 경우, 목록이나 글 보기 화면은 접근 자유도를 위해 GET을 쓰지만, 게시글 저장 수정 삭제 등 대용량 데이터를 전송할 땐 POST 방식을 사용
- HTTP Response
    - 클라이언트의 HTTP Request에 대한 응답 패킷
    - 주요 실행결과 코드
        - 100번대 : 정보 전송
        - 200번대 : 성공
        - 300번대 : 리다이렉션
        - 400번대 : 클라이언트 측 에러
        - 500번대 : 서버 측 에러
- HTTP 3.0
    - 기존 HTTP2에선 TLS 프로토콜에서 3-핸드셰이킹으로 많은 시간이 소요됨
    - HTTP3에선 전송 / 응용 세션의 QUIC 프로토콜이 TLS 1.3을 포함하고 있어 1번만 통신으로 충분해 시간이 3배는 짧아짐

### 프론트엔드

- HTML
    - 클라이언트, 웹 브라우저에서 실행되는 프로그램 영역
    - HTML은 보안적으로 강한 이유가, 정적이어서 애초에 침입해도 뭐 아무것도 없음
    - 서버에 HTML문서를 저장하고 있다가 클라이언트가 특정 HTML 페이지를 요청하면 해당 문서를 전송
- CSS
    - 동적인 웹 서비스. 자바스크립트 등이 사용됨
    - HTML과 마찬가지로 웹 브라우저에 의해 해석 및 적용
    - 서버가 아닌 웹 브라우저에서 해석되어 화면에 적용되므로 서버의 부담을 줄이고 기능 수행

### 백엔드

- 웹 서비스를 제공하는 데 필요한 REST API를 제공하는 영역
- JAVA, 파이썬 등이 사용
- 클라이언트에 구현된 기능에 필요한 인자 전달받은 후 함수처럼 결과를 전달함
- 함수는 URL에 따라 구분되며, 그 결과는 JSON 형태로 클라이언트에 전달

# 웹 해킹

## 스캐너, 프록시

- 웹 취약점 스캐너를 통한 정보 수집
    - 스캐너를 통해 빠르게 다양한 접속 시도를 수행할 수 있음
    - 확인된 취약점은 실제 보안 문제가 있는 취약점이 아닌 경우가 많음
- 웹 프록시를 통한 취약점 분석
    - 웹의 구조를 파악하거나 취약점 점검 시, 웹 해킹할 땐 웹 프록시 툴 사용
    - 클라이언트에 설치되고, 클라이언트의 통제를 받음
    - 클라이언트가 웹 서버와 브라우저 간의 HTTP 패킷을 프록시를 통해 확인, 수정 변조 가능
    - 클라이언트 ↔ 서버 양 방향으로 가는 패킷 모두 변조 가능
    - 즉, 서버가 클라이언트로 보낸 데이터 변조로 인해 발생하는 위험 자체를 없애야 함. 서버에서 클라이언트로 전송한 값을 다시 참조하지 말아야 함.

## 구글 해킹

- 주요 검색 인자에 admin, password 검색 하면 관련 문서가 전부 떠버림
- 웹 해킹을 하며 많은 정보를 수집하려면 구글 검색엔진이 유용
    - site, filetype, link, cache, intitle, inurl…
- 검색 엔진의 검색을 피하는 방법
    - User-agent : googlebot 등으로 검색 엔진의 검색을 막을 수 있음.
    - Disallow: /admin 등의 방법으로 admin 디렉터리 접근을 방지할 수 있음.

# 웹의 취약점과 보안

- 웹의 주요 취약점
    - 국제웹보안표준기구에서 각 분야별 상위 1가지 주요 취약점 발표

### 명령 삽입 취약점

- SQL 인젝션 공격
- 클라이언트의 요청을 처리하기 위해 전송받는 인수에 특정 명령을 삽입
- 필터링하지 못하면 삽입 공격에 대한 취약점이 발생
- SQL, OS, LDAP 등 웹으로 명령을 전달하는 모든 경우에 적용 가능
    - SQL문에서 Where로 입력되는 조건문을 항상 참으로 만들기 위해 조건 값에 or이나 = 삽입
    - password 부분을 or 조건으로 바꾸어 항상 만족되므로 공격자는 사용자 인증에 성공
    - ID는 정상적으로, Password는 ‘or’’=’로, 혹은 주석문을 넣어서

### 인증 및 세션 관리 취약점

- 취약한 패스워드 설정 (admin / admin)
- 사용자 데이터를 이용한 인증
    - 정상적인 아이디와 패스워드로 로그인
    - 해당 값으로 쿠키와 같은 세션 값을 활용
    - 세션 인증 값은 그대로 사용하고, UserNo 값만 변경해 다른 계정으로 로그인한 것처럼 사용

### XSS 취약점 (Cross-Site Scripting)

- XSS : 공격자가 작성한 스크립트가 다른 사용자에게 전달되는 것
- 다른 사용자의 웹 브라우저 안에서 적절한 검증 없이 실행되기 때문에 사용자의 세션 탈취 혹은 웹 사이트 변조, 악의적인 사이트로 이동할 수 있게 됨
- 공격 구조
    - XSS 취약한 서버에 XSS 코드 저장
    - 일반 사용자가 해당 XSS코드에 접근
    - 웹 서버는 사용자 접근에 XSS 코드를 포함한 게시판의 글을 전달
    - 사용자가 XSS 코드를 실행

### 취약한 접근 제어 (Broken Access Control)

- 디렉토리 탐색을 생각할 것
- 인증된 사용자가 수행할 수 있는 것에 대해 제대로 제한을 걸어두지 않은 것을 의미
- 즉, 일반 사용자나 로그인하지 않은 사용자가 관리자 페이지 접근, 권한 기능 악용
- 우회를 막기 위해선 웹의 중요 페이지에 세션 값(쿠키) 확인 검증 로직 작성
- 디렉터리 탐색
    - 웹 브라우저에서 확인 가능한 경로의 상위를 탐색, 특정 시스템 파일을 다운로드
    - URL사이트 위에 download.jsp?filename=비밀파일.hwp를 입력해 파일 다운

### 보안 설정 오류 (Security Misconfiguration)

- 디렉터리 리스팅
    - 웹 브라우저에서 웹 서버의 특정 디렉터리를 열면 그 디렉터리 하위 파일 목록이 보임
- 백업 및 임시 파일 존재
    - 웹 사이트 개발 시 웹 서버 파일이나 임시 파일 삭제를 안해서 공격자가 내부 로직 접속
- 미흡한 주석 관리
    - 일반인도 볼 수 있는 주석에 개발 과정, 주요 로직 설명, 디렉터리 구조, 아이디 패스워드 기록
- 파일 업로드 제한 부재
    - 공격자가 웹 서버에 악의적인 파일 전송, 원격지에서 실행하면 웹 서버 장악 및 내부 침투
    - 다운로드는 자유롭게 해도 되지만 업로드는 정상적인 가입자와 동시에 필터링을 걸어둘 것
- **리버스 텔넷**
    - 공격자가 웹 해킹으로 권한 취득 후, 반대로 공격자 방향으로 텔넷 서버 접속
    - 피해자 컴퓨터에 netcat툴 설치, 23포트를 열어둠
    - 공격자가 해당 IP로 23포트로 접속, 원격으로 파일 취득 및 삭제 가능
    - 스스로 나가는게 아니라 밖에서 나가라고 호출해서 나가게 되는 방식

### 외의 취약점들

- 민감한 데이터 노출
- 공격 방어 취약점
- CSRF 취약점
- 취약점이 있는 컴포넌트 사용
- 취약한 API
- 특수문자 필터링
- 서버 통제  작용
    - css 기반의 언어로 필터링하는건 로직 파악 시 쉽게 무력화됨
    - SSS로 필터링 로직을 수행해야 함
- 지속적인 세션 관리
    - 일관성있는 세션 인증 로직 표준화

# ■ 6주차 (10월 17일)

# 코드 보안

## 시스템 구성과 프로그램 동작

- 하드웨어, 어셈블리어, 소스 코드 중 보안 취약점이 가장 쉽게 발견되는 곳은 소스 코드
- 데이터의 형태와 길이에 대한 불명확한 정의때문에 문제가 발생
    - malloc() 함수 등으로 형태나 길이를 확실하게 정의해야 함
- 시스템 메모리의 구조
    - 상위 메모리 주소엔 환경변수와 명령 창의 데이터를 저장한다.
    - 스택 영역에선 로컬 변수와 프로세스 상태를 저장한다.
    - 힙 영역에선 동적으로 할당된 데이터를 저장한다.
- 스택 영역
    - 로직이 동작하기 위한 인자와 프로세스 상태 저장.
    - 레지스터 임시 저장, 서브루틴 사용 시 복귀 주소 저장, 인자 전달 등에 사용.
    - 스택은 메모리의 상위 주소에서 하위 주소 방향으로 사용. 후입 선출(LIFO) 원칙에 따라 나중에 저장된 값을 먼저 사용.
- 힙 영역
    - 프로그램이 동작할 때 필요한 데이터 정보를 임시로 저장하는데 사용.
    - 가변적인 양의 데이터를 저장하기 위해 프로그램 프로세스가 미리 사용 예약된 영역
    - 힙 영역은 프로그램에 의해 할당되었다가 회수되는 작용을 되풀이함.
    - 포인터 변수를 통해 동적으로 할당받고, 연결리스트나 트리, 그래프 등 동적인 데이터 구조를 만드는데 필요
    - 프로그램 실행 도중 힙 영역이 부족하면 이상 종료
- 레지스터
    - CPU의 임시 메모리로 CPU 연산과 어셈블리어 동작에 필요

- 프로그래 실행 구조
    1. 맨 처음 main함수가 시작되면 main함수의 EBP 레지스터 값을 스택에 저장
    2. ESP 레지스터는 항상 현재 스택 영역에서 가장 하위 주소를 저장
    3. int 정의, 4바이트 할당
    4. 변수 정수들을 저장
    5. function 함수의 RET 저장
    6. function 함수를 호출
    7. function 함수를 기준 값으로, 현재 EBP 값을 스택에 저장
    8. function(1, 2)의 시작에서 프롤로그 (pushl  %ebp) 명령 실행
    9. 12바이트 저장 공간 할당
    10. EBP에 12바이트를 더한 주소 값의 내용을 EAX에 복사
    11. EBP에 8바이트를 더한 주소 값의 내용에 EAX값을 더하면 결과값이 나옴
    12. EDX 레지스터는 입출력 연산에 사용하는 것으로, 큰 수의 곱셈과 나눗셈 연산 시 EAX와 함께 사용. EBP에 8바이트를 더한 주소 값이 내용을 EDX에 저장

- 셸
    - 운영체제를 둘러싸고 있으며 입력받는 명령어를 실행하는 명령어
    - 조개 껍데기에 비유
    - 자체 내장 명령어 제공, 입출력 오류에 대한 리다이렉션 기능
    - 와일드카드 기능, 파이프라인 기능, 서브셸 생성 기능, 후면 처리 기능, 셸 스크립트 기능
- SetUID
    - 유닉스 파일에 rwsr-xr-x로 권한이 설정되어 있는 경우를 말함
    - SetUID 파일은 누가 실행하든 상관없이 해당 파일을 실행할 때 파일 소유자 권한을 갖게 됨

## 버퍼 오버플로우 공격

- 기본적인 버퍼 오버플로 공격은 데이터의 길이에 대한 불명확한 정의를 악용한 덮어쓰기로 발생
- 경계선 관리가 적절하게 수행되어 덮어쓸 수 없는 부분에 햌커가 임의의 코드를 덮어쓰는 것을 의미
- 버퍼 오버플로에 취약한 함수와 그렇지 않은 함수가 있음

- 버퍼 오버플로 공격의 원리
    - 12개까지의 인수가 저장되는 버퍼에 13개 이상의 인수를 넣으면 (strcpy 함수 등은 경계를 체크하지 않음) EBP가 저장되는 공간까지 데이터가 넘쳐버림
    - 세그먼테이션 오류가 발생함
    - 만약 정상적인 RET 주소가 들어가있는 메모리까지 버퍼가 넘치도록 데이터를 잔뜩 삽입한 이후, 해당 메모리에 조작된 RET 주소가 삽입되도록 만들어놓으면 변조된 주소가 리턴

## 포맷 스트링 공격

- 데이터의 형태에 대한 불명확한 정의 때문에 발생하는 문제점
- formatstring.c와 같이 포맷 스트링을 작성하는 것은 정상적인 경우로, 포맷 스트링에 의한 취약점이 발생하지 않음.
- %d, %s, %f 등과 같은 문자열을 포맷 스트링이라고 함.

- 포맷 스트링 공격의 원리
    1. wishfree라는 문자열에 대한 주소 값을 포인터로 지정
    2. 포인터(버퍼)가 가리키는 주소에서 %s를 읽어서 출력 (printf)
    3. 여기서 포맷 스트링인 %s를 바꾸는 것. (명확하게 정의되어 있던 데이터 형태를 바꾸기)
    4. %x\n을 버퍼에 넣음으로서 해당 메모리의 주소가 출력되어버림
    5. 그럼  해당 주소를 사용하여 메모리의 내용을 변조할 수 있음

```c
printf("%64d%n\n", j, &i); // 포맷 스트링을 활용해 데이터 변조
```

## 메모리 해킹

- 프로그램의 동작에 관여하지 않고, 프로그램 실행에 필요한 정보를 저장한 메모리를 조작
- 게임 머니나 아이템 조작 등 게임 해킹에 광범위하게 사용
- 백도어와 같은 프로그램 설치, 메모리의 패스워드를 빼내거나 데이터 조작하여 계좌 변경
- 사용자가 인지하지 못하는 경우가 많고, 휘발성이 강한 메모리 특성상 추적 어려움
- 메모리 해킹을 막으려면 메모리 주소에 저장되는 값을 암호화해야 함
- 지뢰찾기 메모리를 변조하여 플레이 시간을 엄청 높게 만들어버리거나 할 수 있음