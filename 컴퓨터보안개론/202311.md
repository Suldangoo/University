# ■ 9주차 (11월 7일)

# 암호의 이해

## 암호의 개념과 원리

- 암호문
    - 비밀 유지를 위해 당사자만 알 수 있도록 꾸민 약속 기호
    - 평문 → 암호화 → 암호문 → 복호화 → 평문

### 암호화 방식

- 전치법
    - 단순히 메시지에 들어있는 문자 위치를 바꾸는 방법
    - 스파르타의 봉 암호화
- 대체법
    - 메시지의 글자를 다른 글자로 대체하여 암호화
    - 적절한 배합을 찾으면 쉽게 복호화되는 전치법의 문제 해결
    - 단일 치환, 다중 치환으로 나뉠 수 있음
- 단일 치환 암호화
    - 알파벳 한 글자씩 다른 글자로 대체
    - 시저 암호화
        - 알파벳 스물 여섯자를 n자씩 오른쪽으로 이동해 해당되는 글자로 변환
    - 모노 알파베틱 암호화
        - 스물 여섯자를 각각 다른 알파벳에 대응시켜 알파벳 암호화
        - 복호화하려면 알파벳 대칭표가 있어야 함
        - 키워드가 주어지면 해당 키워드의 문자 순서대로 중복 없이 A부터 매칭하고, 이후엔 키워드의 마지막 문자부터 시저 암호화로 이미 쓴 것은 제외하고 쭉 나열
- 다중 치환 암호화
    - 비즈네르 암호화
        - 암호화하려는 평문의 알파벳을 비즈네르 표의 가로축에서 찾음
        - 암호화 키의 첫 문자 알파벳을 비즈네르 표의 세로축에서 찾음
        - 두 축이 겹쳐지는 대칭되는 알파벳으로 암호화
        - 복호화 과정
            - 암호화 키의 첫 문자를 세로축에서 찾음
            - 해당 세로축의 암호문 알파벳을 찾음
            - 그 알파벳의 가로축 알파벳이 평문 알파벳
    - 플레이페어 암호화
        - 초기에는 어렵다는 이유로 사용되지 않았다가, 제 1차 세계대전, 2차 세계대전에 사용
        - 2개로 이루어진 문자 쌍을 다른 문자 쌍으로 대체하는 암호화 방법
        - 5행 5열의 2차원 테이블인 플레이페어 암호화 테이블이 존재
            - 이때 많이 안 쓰는 Z는 그냥 Q칸에 하나로 통합
        - 2개로 이루어진 알파벳 쌍의 문자를 대조하여 치환
            1. 두 문자가 서로 다른 행과 열에 존재하는 경우
                1. 서로가 겹치는 행열을 찾고, 평문과 같은 행에 있는 문자로 치환 (행 우선 방식)
                2. 열 우선 방식이라면 같은 열에 있는 문자로 치환
            2. 두 문자가 같은 열에 있다면 각 한 칸씩 아래에 있는 문자열로 치환
                1. 이 때, 가장 밑에 있는 알파벳이라면 제일 위에로 치환
            3. 두 문자가 같은 행에 있다면, 각 한 칸씩 오른쪽에 있는 문자열로 치환
            4. 두 문자열 쌍이 같은 쌍이거나 마지막에 홀수로 남을 경우 X로 문자열 쌍을 치환

## 대칭 암호화 방식

- 암호화 할때의 키와 복호화 할때의 키가 같은 알고리즘
- DES 알고리즘
    - L1값과 R1값이 S-BOX로 이동, 암호화 키와 조합하여 암호화 후 XOR 연산으로 리턴
    - 모든 단어가 0과 1로 표현
    - S-BOX에 데이터를 넣기 전, 앞뒤 비트를 확장해서 비트를 추가
        - 1011으로 4비트였다면, 1 1011 1 로 6비트로 확장
        - 맨 앞에껀 앞 비트모음의 제일 뒷 비트, 맨 뒤에껀 뒤 비트모음의 제일 뒤 비트
        - 확장 비트 00 ~ 11을 S-Box의 세로열
        - 기존 비트 0000~1111을 S-Box의 가로열
        - 매칭되는 십진수를 2진수로 재전환하면 원래 암호가 됨
- 트리플 DES 알고리즘
    - DES 알고리즘이 복호화가 가능해져서, AES 개발 전까지 임시로 쓰던 암호화 방식
    - DES 암호화를 총 세번 해버림
        - 이 때 두 번째 암호화에선 두 번째 암호화 키를 사용하여 암호화
- AES 알고리즘
    - DES가 약해진 이후, NIST에서 암호화 알고리즘 공모로 제작
- SEED 알고리즘
    - 한국 인터넷 진흥원과 국내 암호 전문가들이 순수 국내 기술로 개발한 128비트 블록 암호화
    - 정보통신단체 표준으로 제정
- ARIA 알고리즘
    - 전자정보 구현으로 다양한 환경에 적합한 암호화 알고리즘 필요
    - 국가보안기술연구소 주도로 개발
    - 2004년 국가표준기본법에 의거하여 국가표준으로 지정
- 양자 암호
    - 1984년 찰스 베넷과 질 브라사스가 BB84라는 프로토콜을 통해 제안
    - BB84 : 양자 채널로 송신자와 수신자가 암호화 키를 공유하게 하는 프로토콜.
        - 베넷, 브라사스의 이름과 84년 연도로 작명
- 기타 대칭형 알고리즘
    - IDEA, RC5, Skipjack, LEA

## 비대칭 암호화 방식

- 암호화 할 때의 키와 복호화 할 때의 키가 다른 암호화 알고리즘
- 공개된 수에 두 사용자 각각의 수를 제곱하여 나온 값을 서로 공유
- 상대방에가 받은 수에 자신의 수를 제곱하면 같은 키가 나옴
    - 공개된 수 : 3
    - 철수의 수 : 5 / 영희의 수 : 7
    - 3^5 = 243 / 3^7 = 2817
    - 2817 ^ 5 = 50031… / 243 ^ 7 = 50031…
    - (3^7)^5 = 50031… / (3^5)^7 = 50031…
    - → 3^35로 서로 동일하여 자신의 수를 가지고 같은 값을 공유
- RSA 알고리즘
    - 비대칭 알고리즘에서 오늘날 산업 표준으로 사용
    - MIT의 리베스트, 샤미르, 애들먼이 개발했으며, 각각의 앞글자를 따서 작명
    - 기본적인 정수론 (소수) 사용
    - 중요 정보를 소수 2개로 표현한 후, 두 소수의 곱을 힌트와 함께 전송하여 암호화
    - p와 q값이 소수로 이루어져있으며, 이 두 값의 곱을 모든이에게 공개된 N값으로 사용
    - 현대에선 p와 q값이 거의 스무자리 가깝게 길어 두 수를 곱하면 400자리가 넘어감
        - 이는 슈퍼컴퓨터로 해결하려고 해도 수광년이 걸림

### 비대칭 암호화의 구조

- RSA 알고리즘이 나오며 정립
- 각 개인이 공개 키와 개인 키를 소유하는 구조, 서로의 개인 키는 얻을 수 없음
- 언제나 한 쌍의 개인 키와 공개 키로 암호화와 복호화가 이루어짐
    - 개인 키로 암호화한 것은 공개 키로 복호화하여 평문화
    - 공개 키로 암호화한 것은 개인 키로 복호화하여 평문화
- **기밀성**
    - 비대칭 암호화 알고리즘은 대칭 암호화 알고리즘보다 더 엄밀한 기밀성을 제공
    - 예를들어, A가 B에게 메시지를 보낼 때, B의 공개 키를 잘 찾아 암호화하고 B에게 전송
    - B는 받은 암호화 메시지를 자신의 개인 키로 복호화하여 평문화
    - 즉, 암호화된 메시지가 중간에 다른 사람에게 가로채져도 개인 키가 없으므로 안전
- **부인 방지**
    - 대칭 암호화 알고리즘에는 없는 기능으로, ‘발뺌 방지’ 기능
    - A의 개인 키로 암호화된 메시지는 A의 공개 키로밖에 열 수 없음
    - 즉, 해당 메시지가 A의 공개 키로 풀린다면 반드시 A가 만든 메시지임을 확신 가능

## 해시

### 해시의 특징

- 하나의 문자열을 더 짧은 길이의 값이나 키로 변환
- 대표적인 해시 알고리즘은 MD5
- 어떠한 평문을 해시 알고리즘을 돌리면, 해당 평문의 길이가 길든 짧든 32개 문자로 길이가 모두 같게 나옴.
- 단어나 문자가 하나만 바뀌어도 해시 결과가 완전히 달라짐
- 해시는 일방적인 변환이므로, 해시 결과를 가지고 평문을 만들 순 없음.
    - 즉, 이것은 암호화가 아니라 평문의 위조, 변조 (**무결성**)를 확인하기 위한 수단
- 충돌 : 다른 값의 데이터를 입력했는데 해시 결과 값이 같을 수도 있는 상황이 있음

### 해시의 역할

- DB 탐색을 효과적으로 구현하기 위해 만들어진 것이었음
- 데이터가 임의로 변경되지 않았다는 무결성 확인

### 해시의 종류

- MD 알고리즘
    - 로널드 리베스트가 공개 키 기반 구조 제작을 위해 RSA와 함꼐 개발. MD2, 4, 5가 있음
- SHA
    - 160비트 값을 생성하는 해시 함수, MD4가 발전한 형태
    - MD5보다 조금 느리지만 좀 더 안전하며, SHA-1과 SHA-2로 나눌 수 있음

# ■ 10주차 (11월 14일)

## 전자 상거래의 이해

- 비디오택스
    - 전화선을 이용해 통신하는 개조된 TV, 최초의 온라인 쇼핑
    - 2년 뒤에 비디오텍스를 이용해 은행 업무 서비스를 제공 (온라인 홈뱅킹)
- 전자 상거래의 시작
    - 1994년에 피자헛이 처음으로 웹 사이트를 통해 주문을 받음
        - 이 시기에 만들어진 넷스케이프 1.0은 SSL 암호화로 안전한 거래 제공
    - 1995년에 제프 베저스가 세계 최초의 가상 서점 아마존 설립

### 전자 상거래의 보안 요건

- 전자 상거래 공격 유형
    - 인증 공격 : 네트워크로 접근한 사용자가 적절치 않은 인증으로 다른 사용자로 위장
    - 송수신 부인 공격 : 네트워크를 통해 수행한 인증 및 거래 내역을 부인하는 것
    - 기밀성 공격 : 네트워크로 전달되는 인증 정보 및 주요 거래 정보가 유출되는 것
    - 무결성에 대한 공격 : 네트워크 도중에 거래 정보 등이 변조되는 것
- 전자 상거래가 성공하기 위한 보안 요건
    - 신분 확인 수단 제공 : 원격의 거래 상대에게 자신의 신분 확인 수단 필요
    - 제삼자의 중재 : 거래 사실을 공증할 수 있는 신뢰할만한 제삼자의 중재 필요
    - 지불 방식의 안전성 : 전자지불 방식의 안전성을 보장하는 방법이 확보되어야 함
    - 블록체인을 활용하는 비트코인과 같은 거래체계가 활성화된다면 전자 상거래의 세 가지 보안 요건 중 제삼자의 중재는 앞으로 완전히 사라질 수 있음

## 공개 키 기반 구조 (PKI)

- 메시지의 암호화 및 전자 서명을 제공하는 복합적인 보안 시스템 환경
- 일반적으로 공인 인증서를 생각하면 됨
- 공개 키 기반 구조는 ‘인터넷에서 신분증을 검증해주는 관청’의 역할
- 가까운 관청인 주민센터 위에 구청, 시청이 있고, 맨 위에 정부가 있는 것과 마찬가지
- 공개 키 기반 구조에 속하는 사람은 어디서든 인증기관(CA)에서 공인인증서로 증명 가능
- 트리형 공개 키 기반 구조
    - 공개 키 기반 구조가 되려면 인증 정보를 일원화, 호환성 갖춤. 개인이 쉽게 접근ㅣ.
    - 순수 계층 구조 : 트리형으로 구성된 공개 키 기반 구조
    - PAA - PCA - CA - RA 순으로 낮아짐
- 상호 인증으로 연결된 공개 키 기반 구조
    - 인증 기관이 상호 인증을 통해 연결되어 있는 모델도 존재

### 공인인증서

- 공개 키와 공개 키의 소유자를 연결해주는 전자 문서
- 오늘날 대부분 X.509 인증서를 표준으로 따름
- 공인인증서의 특성
    - 누구나 사용자의 공인 인증서와 공개 키 획득
    - 인증 기관 외에는 공인 인증서를 수정 및 발급할 수 없음 (무결성)
    - 같은 인증 구조 내의 사용자 간에는 상호 인증의 신뢰가 가능
- 공인인증서의 구성
    - 버전, 일련번호, 서명 알고리즘 (SHA), 발급자, 유효기간, 주체, 공개 키
- 공인인증서의 폐기
    - 시기적절하게 폐기해야 피해를 줄일 수 있음
    - 인증 기관에서 인증서 폐기 목록(CRL)을 주기적으로 발급
    - 폐기 목록도 인증기관이 전자서명을 하여 발급

## 전자 서명과 전자 봉투

- 전자 서명법 : 서명자가 해당 전자 문서에 서명하였음을 나타내기 위해 전자문서에 첨부되거나 논리적으로 결합된 전자적 형태의 정보
- 인감도장철머 전자서명도 공인된 인증 기관에 등록 및 검증하여 사용 가능
    - 대면하여 인감 날인(증명)을 하고, 주민센터에서 인감 증명서를 발급하는것과 유사
    - 사이버 공간에서 전자 서명(인증)을 하고, 전자 계약서 보관.

### 전자서명

- 전자 서명은 원본의 해시 값을 구한 뒤 부인 방지 기능을 부여하기 위해 공개 키 방법을 사용
    - 원본 해시 → 소유자의 개인키로 암호화 → 이것이 전자 서명
    - 즉, 이후 철수의 공개키로 무결성이 확인되면 위조되지 않았다고 확신할 수 있음
- 해당 원본이 자신 것이라는 서명. (내 개인키로 암호화를 한 서명은, 나만이 만들 수 있음)
- 제공하는 기능
    - 위조 불가 (서명자만이 서명문을 작성)
    - 인증 (서명문의 서명자를 확인)
    - 재사용 불가 (서명문의 해시값을 전자서명에 이용, 한 번 생성된 서명을 다른 문서의 서명으로 사용할 수는 없음)
    - 변경 불가 (서명된 문서는 내용을 변경할 수 없음. 무결성 보장)
    - 부인 방지 (서명자가 서명한 사실을 나중에 부인할 수 없음)
- 전자 서명의 대표적인 표준
    - 1994년 미국의 DSS, 우리나라엔 1996년 개발된 KCDSA가 있음

### 전자봉투

- 전달하려는 메시지를 암호화하여 한 사람을 통해 보내고, 암호화 키는 다른 사람이 가져가도록 암호학적으로 구현
- 암호화의 종합 선물 세트라 할 만큼 많은 기능 제공
- 전자 서명 문서를 누군가가 보면 안되므로, 그 자체를 한 번 더 통째로 암호화 한 것
- 전자 봉투 생성 과정
    1. 전자 서명을 생성
    2. 전자 서명과 원문, 공개 키가 들어있는 인증서를 비밀키로 암호화
    3. 전자 서명 세트와 인증서, 비밀키가 받는 사람의 공개 키로 암호화
    4. 최종적으로 비밀 키로 암호화한 결과와 비밀 키가 암호화된 전자 봉투를 전송
- 전자 봉투 복호화 과정
    1. 전자 봉투를 받는 사람의 개인키로 해독, 비밀 키 획득
    2. 비밀 키로 암호문을 해독하면 전자 서명이 등장
- 전자봉투는 기밀성, 무결성, 부인방지를 모두 지원

## 전자 결제와 가상 화폐

- SET
    - 1996년 비자와 마스터카드가 합의로 만들어진 프로토콜
    - 신용카드 거래에서 사실상의 표준
- SET 구성
    - 신용카드 사용자 : SET에 이용하는 공인 인증서를 소유
    - 상점 : 인터넷 쇼핑몰을 운영하며 SET을 이용하여 상품을 판매
    - 지불 게이트웨이 : 기존의 신용카드 지불 방식으로 은행과 거래내역을 주고받음
    - 신용카드 회사 : 사용자에게 카드 발급, CA 운영하여 사용자에게 공인인증서 발급
    - 은행 : 상점의 계좌가 있는 곳. 지불 게이트웨이 운영, CA를 운영하여 상점에 공인인증서 발급
    - 인증기관 : SET에 참여하는 모든 구성원의 정당성을 보장하는 루트 CA
- 비자 / 마스터카드 루트 CA가 신용카드 회사와 은행을 인증함
- 신용카드 회사는 사용자에게 카드 발급, 대금을 받음
- 은행은 상점에게 대금을 지급함. 지불 게이트웨이를 운영
- SET 지불 과정
    - 신용카드 사용자가 SET을 이용하여 상점에 결제 의뢰
    - 주문서를 받은 판매자는 고객의 신용카드 회사에서 신용카드 유효성 여부 확인
    - 신용카드가 정상임윽 확인, 주문 확인 메시지 전송
    - 고객은 자신의 신용카드 정보를 판매자에게 전송
    - 판매자는 고객에게 받은 정보를 신용카드 결제에 이용, 이 때 SET은 전자봉투와 이중서명 사용
- 이중 서명
    - 신용카드 사용자의 구매 정보와 지불 정보를 각각 해시한 후, 두 값을 합하여 다시 해시
    - 최종 해시 값을 신용카드 사용자의 개인 키로 암호화(서명)하면 이중 서명 값 생성
    - 상점에 대금을 지불하는 은행은 신용카드 사용자가 구입한 물건을 모르지만, 상점이 요구한 결제 대금이 정확한지 확인 할 수 있게 하기 위한 목적
- 이중 서명의 원리
    - 신용카드 사용자는 하나의 비밀 키를 생성
    - 비밀 키를 사용하여 지불 정보 암호화
    - 비밀 키는 은행이 운영하는 지불 게이트웨이의 공개 키로 암호화
    - 신용카드 사용자는 결제를 위한 데이터를 모두 생성하여 상점에 전송
    - 상점은 구매 정보를 확인
        - 신용카드 사용자가 구매한 물건에 대한 구매 정보의 해시를 구함
        - 신용카드 사용자가 보내온 한 쌍의 해시 값을 새로 구한 해시로 대치
        - 새로운 이중 해시를 구함
        - 신용카드 사용자의 개인 키로 암호화된 해시 값을 복호화, 새로 구한 이중 해시값과 비교
    - 구매 정보를 확인한 상점은 다시 데이터 세트를 만들어 지불 게이트웨이로 전송
    - 상점이 지불 게이트웨이로 보내는 데이터는 구매 정보만 빼면 신용카드 사용자가 처음 상점에 전송한 데이터와 같음
    - 데이터를 상점으로부터 받은 지불 게이트웨이는 자신의 개인 키로 비밀 키 복호화, 지불정보확인
    - 상점이 한 것처럼 지불 정보를 해시한 값으로 대치하여 이중 해시 값을 비교
    - 지불 정보의 변조 여부를 확인한 뒤 상점에 대금을 지불

### 간편결제

- 모바일 앱이나 웹 서비스 사용자에게 신용카드 정보 등을 입력, 결제 시 신용카드 정보 입력과 공인인증서 등록 없이 패스워드 입력같은 간단한 인증만으로 결제
- 최근에는 보안성보다 간편성에 더 중점
- 간편결제를 기존의 신용카드 보안, 은행 입출금 보안에 간편성을 더한 것으로 볼 수도 있음

### 전자화폐

- 이전 가능한 금전적 가치가 전자적 방법으로 저장되어 발행된 증표
- 소액 거래 포인트처럼 사용되고 있으며, 전세계적으로 성공 사례가 적음
- 위험성
    - 구현된 방식에 따라 쉽게 복제 가능
    - 인터넷에서 다양한 경로로 사용되어 취약점에 노출되는 경우가 많음
    - 전자화폐를 도입할 땐 이러한 위험성을 충분히 파악하고 신중하게 결정

### 스마트카드

- 접촉식 카드
    - 카드 리더기와 IC칩을 활용해 접촉
    - 많은 데이터를 처리하는 거래 인증이나 전자 서명 등의 응용에 적합
    - 잦은 접촉으로 인해 접점이 전기적 충격을 받거나 손상 가능성
- 비접촉식 카드
    - 안테나 겸 전기 코일로 비접촉 (지하철)
- 콤비 카드
    - 접촉식과 비접촉식 카드가 공유할 수 있는 부분을 상호 공유하는 스마트카드
- SIM 카드
    - 가입자 식별 모듈을 구현한 IC카드로, 단말기 필수 요소
    - 보안성이 뛰어나며, USIM으로 표준이 확장

### 스마트카드 인증

- 정적 데이터 인증
    - 인증할 때마다 같은 데이터를 사용
    - 정적 데이터 인증을 이용한 스마트카드의 대표적인 예는 출입 카드
    - 발행사에서 데이터를 암호화하여 카드에 넣어두고, 리더기는 공개키를 가지고있어 인증 기관으로 데이터를 보내고 인증 확인
- 동적 데이터 인증
    - 인증할 때마다 다른 데이터를 사용하는 방식
    - 보안 수준이 높고, IC카드 측에 암호 계산을 위한 암호화 프로세서가 탑재되어있음.

## 암호화 통신

## 콘텐츠 보안